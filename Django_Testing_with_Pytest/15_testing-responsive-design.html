<html><head><meta content="light dark" name="color-scheme"/><link href="../style/icons/default/16x16.png" rel="icon"/><link href="../style/themes/github-dark.css" id="_theme" rel="stylesheet" type="text/css"/><link href="../style/vendor/prism-okaidia.min.css" id="_prism" rel="stylesheet" type="text/css"/><link defer="" href="../style/style.css" rel="stylesheet"/><style>
.pre-container {
    position: relative;
}

.copy-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    padding: 3px 8px;
    font-size: 12px;
    background-color: #800000; /* Maroon */
    color: white;
    border: 1px solid #5c0000; /* Darker maroon */
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.copy-btn:hover {
    background-color: #a00000; /* Lighter maroon on hover */
}

.copy-btn.copied {
    background-color: #006400; /* Dark Green */
    border-color: #004d00;
    color: white;
}

.copy-btn.failed {
    background-color: #dc3545; /* Red */
    border-color: #c82333;
    color: white;
}
</style></head><body class="_theme-github _color-light"><div class="markdown-body" id="_html" style="visibility: visible;"><div class="akbar_container"><h1 id="chapter-15-testing-responsive-design" tabindex="-1"><a class="anchor" href="#chapter-15-testing-responsive-design" name="chapter-15-testing-responsive-design" tabindex="-1"><span class="octicon octicon-link"></span></a>Chapter 15: Testing Responsive Design</h1>
<h3 id="151-defining-viewports-pageset_viewport_size" tabindex="-1"><a class="anchor" href="#151-defining-viewports-pageset_viewport_size" name="151-defining-viewports-pageset_viewport_size" tabindex="-1"><span class="octicon octicon-link"></span></a>15.1 Defining Viewports (<code>page.set_viewport_size</code>)</h3>
<p>Responsive Web Design (RWD) is a cornerstone of modern web development. It ensures that your Django application provides an optimal viewing and interaction experience across a wide range of devices, from desktops to tablets and mobile phones. The key to RWD is the browser's <strong>viewport</strong>, which is essentially the user's visible area of a web page. The content layout often changes dynamically based on the viewport's dimensions, typically through CSS media queries and sometimes JavaScript.</p>
<p>To effectively test responsive features, we must be able to simulate these different viewport sizes programmatically. This is where Playwright's <code>page.set_viewport_size()</code> method becomes indispensable.</p>
<p><strong>What is <code>page.set_viewport_size()</code>?</strong></p>
<p>The <code>page.set_viewport_size()</code> method, available on Playwright's <code>Page</code> object (which you access via the <code>page</code> fixture), allows you to explicitly define the dimensions (width and height) of the browser's viewport for your test.</p>
<p><strong>Why is it crucial for responsive testing?</strong></p>
<ol>
<li><strong>Simulating Devices:</strong> It lets you mimic how your Django application would render on specific devices. For example, you can set the viewport to match an iPhone X, a Samsung Galaxy Tab, or a standard desktop resolution.</li>
<li><strong>Triggering Responsive Logic:</strong> By changing the viewport size, you trigger the same CSS media queries and JavaScript logic that adapt your site's layout and behavior in a real user's browser.</li>
<li><strong>Targeted Testing:</strong> It enables you to write tests that specifically verify layouts, element visibility, or functionality unique to certain screen sizes. Without it, your tests would likely run against a default (often desktop) viewport, potentially missing mobile-specific bugs or UI issues.</li>
</ol>
<p><strong>How does it work "under the hood"?</strong></p>
<p>When you call <code>page.set_viewport_size({"width": 375, "height": 667})</code>, Playwright communicates with the browser engine (Chromium, Firefox, or WebKit) it's controlling. It instructs the browser to adjust its rendering canvas to these exact pixel dimensions. The browser then re-evaluates the page's CSS, applying any media queries that match the new viewport size, and re-runs relevant JavaScript, effectively re-rendering the page as if it were on a device with that screen size. This is far more precise and reliable for testing than attempting to resize the entire browser window, as <code>set_viewport_size</code> targets the content area itself.</p>
<p>Let's look at a practical example of how to use this in a <code>pytest-playwright</code> test.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token keyword">import</span> pytest
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page
<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> reverse

<span class="token comment"># A simple view for demonstration purposes</span>
<span class="token comment"># In your project, this would be in a views.py file</span>
<span class="token comment"># from django.http import HttpResponse</span>
<span class="token comment"># def responsive_home_view(request):</span>
<span class="token comment">#     return HttpResponse("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;")</span>

<span class="token comment"># Ensure your urls.py has a path for 'responsive_home'</span>
<span class="token comment"># urlpatterns = [</span>
<span class="token comment">#     path('responsive-home/', responsive_home_view, name='responsive_home'),</span>
<span class="token comment"># ]</span>

<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>django_db</span>
<span class="token keyword">def</span> <span class="token function">test_homepage_on_mobile_viewport</span><span class="token punctuation">(</span>page<span class="token punctuation">:</span> Page<span class="token punctuation">,</span> live_server<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    Tests that we can set a mobile viewport and load the homepage.
    """</span>
    <span class="token comment"># Define mobile viewport dimensions (e.g., iPhone X)</span>
    mobile_viewport <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"width"</span><span class="token punctuation">:</span> <span class="token number">375</span><span class="token punctuation">,</span> <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">812</span><span class="token punctuation">}</span> <span class="token comment"># iPhone X dimensions</span>

    <span class="token comment"># 1. ARRANGE: Set the viewport size</span>
    page<span class="token punctuation">.</span>set_viewport_size<span class="token punctuation">(</span>mobile_viewport<span class="token punctuation">)</span>

    <span class="token comment"># Construct the URL for the homepage using Django's reverse</span>
    <span class="token comment"># Assuming you have a URL named 'responsive_home'</span>
    home_url <span class="token operator">=</span> live_server<span class="token punctuation">.</span>url <span class="token operator">+</span> reverse<span class="token punctuation">(</span><span class="token string">'responsive_home'</span><span class="token punctuation">)</span> <span class="token comment"># Replace 'responsive_home' with your actual URL name</span>

    <span class="token comment"># 2. ACT: Navigate to the homepage</span>
    page<span class="token punctuation">.</span>goto<span class="token punctuation">(</span>home_url<span class="token punctuation">)</span>

    <span class="token comment"># 3. ASSERT (Implicit): For this example, we're just ensuring no errors.</span>
    <span class="token comment"># In a real test, you'd add assertions here to check responsive behavior.</span>
    <span class="token comment"># For example, checking if a mobile-specific menu icon is visible.</span>
    <span class="token comment"># from playwright.sync_api import expect</span>
    <span class="token comment"># expect(page.locator("h1")).to_have_text("Welcome!") # A basic assertion</span>

    <span class="token comment"># Optional: Take a screenshot to visually verify</span>
    page<span class="token punctuation">.</span>screenshot<span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"test_output/mobile_homepage.png"</span><span class="token punctuation">)</span>

    <span class="token comment"># Verify the viewport size was applied (more for demonstration)</span>
    current_viewport <span class="token operator">=</span> page<span class="token punctuation">.</span>viewport_size
    <span class="token keyword">assert</span> current_viewport<span class="token punctuation">[</span><span class="token string">"width"</span><span class="token punctuation">]</span> <span class="token operator">==</span> mobile_viewport<span class="token punctuation">[</span><span class="token string">"width"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> current_viewport<span class="token punctuation">[</span><span class="token string">"height"</span><span class="token punctuation">]</span> <span class="token operator">==</span> mobile_viewport<span class="token punctuation">[</span><span class="token string">"height"</span><span class="token punctuation">]</span>

</code></pre>
<p>Let's examine this code in detail:</p>
<ol>
<li>
<p><strong><code>import pytest</code> and <code>from playwright.sync_api import Page</code> and <code>from django.urls import reverse</code></strong>:</p>
<ul>
<li>We import <code>pytest</code> for the testing framework, <code>Page</code> for type hinting the <code>page</code> fixture provided by <code>pytest-playwright</code>, and <code>reverse</code> from Django to dynamically generate URLs. This is a good practice as it avoids hardcoding URLs, making tests more resilient to URL changes.</li>
</ul>
</li>
<li>
<p><strong><code>@pytest.mark.django_db</code></strong>:</p>
<ul>
<li>This marker is crucial. It ensures that a dedicated test database is set up for this test and that Django's settings are configured correctly. Even if this specific test doesn't directly interact with the database for assertions, the page being loaded by <code>live_server</code> might, so it's essential.</li>
</ul>
</li>
<li>
<p><strong><code>def test_homepage_on_mobile_viewport(page: Page, live_server):</code></strong>:</p>
<ul>
<li>This defines our test function.</li>
<li><code>page: Page</code>: This requests the <code>page</code> fixture from <code>pytest-playwright</code>, which provides an instance of Playwright's <code>Page</code> object, our primary tool for interacting with the browser.</li>
<li><code>live_server</code>: This fixture (from <code>pytest-django</code>) starts a live Django development server running your application in a separate thread. This is essential for E2E tests because Playwright needs a running server to navigate to. It also ensures this server uses the isolated test database.</li>
</ul>
</li>
<li>
<p><strong><code>mobile_viewport = {"width": 375, "height": 812}</code></strong>:</p>
<ul>
<li>This dictionary defines the desired viewport dimensions. We've chosen dimensions typical of an iPhone X.</li>
<li>The <code>width</code> and <code>height</code> are specified in pixels.</li>
<li>This approach (defining it as a variable) makes the code cleaner and easier to modify if you want to test other viewport sizes.</li>
</ul>
</li>
<li>
<p><strong><code>page.set_viewport_size(mobile_viewport)</code></strong>:</p>
<ul>
<li>This is the core action of this section. We call the <code>set_viewport_size()</code> method on the <code>page</code> object.</li>
<li>We pass our <code>mobile_viewport</code> dictionary as the argument.</li>
<li><strong>Why now?</strong> It's generally best practice to set the viewport size <em>before</em> navigating to the page (<code>page.goto()</code>) or very early in your test. This ensures that the initial page load and rendering occur with the intended dimensions, accurately reflecting how a user on that device would experience it. If the page has JavaScript that reacts to <code>resize</code> events on load, setting the viewport first ensures this logic runs correctly.</li>
</ul>
</li>
<li>
<p><strong><code>home_url = live_server.url + reverse('responsive_home')</code></strong>:</p>
<ul>
<li><code>live_server.url</code> provides the base URL (e.g., <code>http://localhost:8081</code>) of the running test server.</li>
<li><code>reverse('responsive_home')</code> dynamically looks up the path for the URL pattern named <code>responsive_home</code> in your Django <code>urls.py</code>. You would replace <code>'responsive_home'</code> with the actual name of the URL pattern for the page you want to test.</li>
<li>Concatenating them gives the full URL for Playwright to navigate to.</li>
</ul>
</li>
<li>
<p><strong><code>page.goto(home_url)</code></strong>:</p>
<ul>
<li>This instructs Playwright to navigate the current browser page to the specified <code>home_url</code>. The page will be rendered using the viewport dimensions set in the previous step.</li>
</ul>
</li>
<li>
<p><strong><code>page.screenshot(path="test_output/mobile_homepage.png")</code></strong>:</p>
<ul>
<li>This is an optional but highly useful step for debugging and verification. It captures an image of the page as rendered in the specified viewport.</li>
<li>You can then manually inspect <code>mobile_homepage.png</code> (which will be saved in a <code>test_output</code> directory relative to where you run pytest) to see if the layout appears as expected for a mobile device.</li>
</ul>
</li>
<li>
<p><strong><code>current_viewport = page.viewport_size</code></strong>:</p>
<ul>
<li>The <code>page.viewport_size</code> attribute is a read-only property that returns a dictionary containing the current <code>width</code> and <code>height</code> of the viewport. This is useful for confirming that <code>set_viewport_size</code> had the intended effect.</li>
</ul>
</li>
<li>
<p><strong><code>assert current_viewport["width"] == mobile_viewport["width"]</code></strong> and <strong><code>assert current_viewport["height"] == mobile_viewport["height"]</code></strong>:</p>
<ul>
<li>These assertions explicitly check if the browser's current viewport dimensions match what we intended to set. While <code>set_viewport_size</code> is generally reliable, this can be a good sanity check, especially when learning or debugging.</li>
</ul>
</li>
</ol>
<p><strong>Mental Model Recap:</strong></p>
<p>Think of <code>page.set_viewport_size()</code> as handing the browser a specific pair of "glasses." These glasses dictate the exact dimensions through which the browser views and renders the web page. If the page is designed to be responsive, it will adapt its appearance to fit these dimensions, just as it would on a real device with that screen size.</p>
<p><strong>When to Use <code>set_viewport_size()</code>:</strong></p>
<p>You should use <code>page.set_viewport_size()</code> at the beginning of any test (or in a fixture, as we'll see in Chapter 16) where you intend to:</p>
<ul>
<li>Verify layout or element visibility specific to a particular screen size (mobile, tablet, desktop).</li>
<li>Test functionality that changes based on viewport dimensions (e.g., a mobile navigation menu vs. a desktop navigation bar).</li>
<li>Ensure a consistent baseline for visual regression testing (covered briefly later).</li>
</ul>
<p>Setting the viewport is the foundational first step in testing the responsive aspects of your Django application. With the viewport correctly defined, you can then proceed to use Playwright's locators (Chapter 11) and assertions (Chapter 12) to verify that your application behaves and appears correctly across different device simulations. In the subsequent sections of this chapter, we'll explore how to leverage this capability to build comprehensive responsive design tests.</p>
<h3 id="152-parameterizing-tests-for-multiple-breakpoints-pytestmarkparametrize" tabindex="-1"><a class="anchor" href="#152-parameterizing-tests-for-multiple-breakpoints-pytestmarkparametrize" name="152-parameterizing-tests-for-multiple-breakpoints-pytestmarkparametrize" tabindex="-1"><span class="octicon octicon-link"></span></a>15.2 Parameterizing Tests for Multiple Breakpoints (<code>@pytest.mark.parametrize</code>)</h3>
<p>In the previous section, we learned how to use <code>page.set_viewport_size()</code> to test our Django application's responsiveness at a specific screen dimension. While this is a crucial first step, you've likely already anticipated a practical challenge: applications need to look and function correctly across a <em>range</em> of viewport sizes â€“ desktops, tablets, and various mobile devices.</p>
<p>Manually writing a separate test function for each breakpoint, like <code>test_homepage_desktop_layout()</code>, <code>test_homepage_tablet_layout()</code>, and <code>test_homepage_mobile_layout()</code>, would lead to significant code duplication. Each test would largely repeat the same navigation and interaction steps, differing only in the viewport dimensions and perhaps some assertions. This approach is not only tedious to write but also a nightmare to maintain. If a common part of the user flow changes, you'd need to update it in multiple places.</p>
<p>This is precisely where Pytest's parameterization feature, <code>@pytest.mark.parametrize</code>, becomes an invaluable tool. It allows us to run the same test function multiple times with different sets of arguments, elegantly solving the problem of testing across various breakpoints without redundant code.</p>
<p><strong>Understanding the "Why": The Power of Parameterization</strong></p>
<p>At its core, parameterization is about abstracting the data or configuration that varies between test scenarios away from the test logic itself. Think of it as a way to tell Pytest: "Here's a template for a test, and here's a list of different inputs I want you to run this template with. For each input set, treat it as a completely separate test."</p>
<p>This approach aligns perfectly with the DRY (Don't Repeat Yourself) principle, a cornerstone of good software development. By parameterizing, we:</p>
<ol>
<li><strong>Reduce Redundancy</strong>: Write the test logic once.</li>
<li><strong>Improve Clarity</strong>: Clearly define the different scenarios (in our case, viewports) being tested at the top of the test function.</li>
<li><strong>Enhance Maintainability</strong>: If the core test logic needs to change, you only modify it in one place. Adding a new viewport to test becomes as simple as adding a new entry to a list.</li>
<li><strong>Get Granular Feedback</strong>: Pytest treats each parameterized run as an individual test case. If a test fails for one specific viewport, the test report will pinpoint exactly which scenario failed, rather than a generic failure for a monolithic test function.</li>
</ol>
<p><strong>The Mechanics of <code>@pytest.mark.parametrize</code></strong></p>
<p>The <code>@pytest.mark.parametrize</code> decorator is applied directly above a test function. Its basic syntax is:</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize</span><span class="token punctuation">(</span><span class="token string">"argument_name_string"</span><span class="token punctuation">,</span> list_of_argument_values<span class="token punctuation">)</span>
</code></pre>
<p>Let's break this down:</p>
<ol>
<li>
<p><strong><code>"argument_name_string"</code></strong>: This is a string containing one or more comma-separated names. These names become arguments that Pytest will inject into your test function. For example, <code>"width, height"</code> or <code>"username, password, expected_outcome"</code>.</p>
</li>
<li>
<p><strong><code>list_of_argument_values</code></strong>: This is a list (or any iterable) of tuples. Each tuple in the list represents one complete set of values for the arguments defined in <code>argument_name_string</code>. The number of elements in each tuple must match the number of argument names.</p>
<ul>
<li>If you have one argument name, say <code>"input_value"</code>, the list would look like <code>[ (value1,), (value2,), (value3,) ]</code>. Notice the trailing comma to make <code>(value1,)</code> a tuple. Simpler, you can just provide <code>[value1, value2, value3]</code> if there's only one argument.</li>
<li>If you have multiple argument names, say <code>"width, height"</code>, the list would be <code>[ (1920, 1080), (768, 1024), (375, 667) ]</code>.</li>
</ul>
</li>
</ol>
<p>Pytest will then generate and run a separate test for each tuple in the <code>list_of_argument_values</code>. In each run, the test function will receive the corresponding values as arguments.</p>
<p><strong>A Simple Illustrative Example (Non-Playwright)</strong></p>
<p>Before diving into responsive design, let's solidify our understanding with a basic example unrelated to browser testing. Imagine we have a simple function <code>add(a, b)</code> that we want to test with various inputs.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># File: test_simple_math.py</span>

<span class="token keyword">import</span> pytest

<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b

<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize</span><span class="token punctuation">(</span><span class="token string">"num1, num2, expected_sum"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment"># Test case 1</span>
    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment"># Test case 2</span>
    <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment"># Test case 3</span>
    <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment"># Test case 4</span>
    <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment"># Test case 5</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">test_addition</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> expected_sum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">assert</span> add<span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token operator">==</span> expected_sum
</code></pre>
<p>Let's examine this code in detail:</p>
<ol>
<li><strong><code>import pytest</code></strong>: We import the <code>pytest</code> library to use its features, specifically the <code>parametrize</code> marker.</li>
<li><strong><code>def add(a, b): return a + b</code></strong>: This is the simple function we intend to test. In a real Django project, this would be a component of your application.</li>
<li><strong><code>@pytest.mark.parametrize("num1, num2, expected_sum", [...])</code></strong>: This is the parameterization decorator.
<ul>
<li><code>"num1, num2, expected_sum"</code>: We define three argument names that our test function <code>test_addition</code> will receive.</li>
<li><code>[...]</code>: This list contains five tuples. Each tuple provides a set of values for <code>num1</code>, <code>num2</code>, and <code>expected_sum</code> for one test run.
<ul>
<li>For example, the first tuple <code>(1, 2, 3)</code> means Pytest will run <code>test_addition</code> with <code>num1=1</code>, <code>num2=2</code>, and <code>expected_sum=3</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>def test_addition(num1, num2, expected_sum):</code></strong>: The test function now accepts <code>num1</code>, <code>num2</code>, and <code>expected_sum</code> as parameters. These will be populated by Pytest during each parameterized run.</li>
<li><strong><code>assert add(num1, num2) == expected_sum</code></strong>: The core assertion of the test. It uses the parameterized values to call the <code>add</code> function and checks if the result matches the <code>expected_sum</code> for that specific set of inputs.</li>
</ol>
<p>If you run <code>pytest</code> on this file, the output would indicate that five tests were run and passed (assuming the <code>add</code> function is correct):</p>
<pre><code>$ pytest -v
============================= test session starts ==============================
...
collected 5 items

test_simple_math.py::test_addition[1-2-3] PASSED                      [ 20%]
test_simple_math.py::test_addition[5-5-10] PASSED                     [ 40%]
test_simple_math.py::test_addition[-1-1-0] PASSED                     [ 60%]
test_simple_math.py::test_addition[0-0-0] PASSED                      [ 80%]
test_simple_math.py::test_addition[100-200-300] PASSED                [100%]

============================== 5 passed in 0.xxs ===============================
</code></pre>
<p>Notice how Pytest generates unique identifiers for each test case, like <code>test_addition[1-2-3]</code>. This is extremely helpful for debugging, as you can immediately see which specific set of parameters caused a failure. This demonstrates Pytest's strength in generating multiple test instances from a single function definition, each with its own context.</p>
<p><strong>Applying <code>@pytest.mark.parametrize</code> to Viewport Testing</strong></p>
<p>Now, let's bring this powerful concept back to testing responsive design in our Django application with Playwright. We want to test how a page behaves at different viewport sizes.</p>
<p>Suppose our homepage (<code>/</code>) has a navigation bar that behaves differently on desktop, tablet, and mobile:</p>
<ul>
<li><strong>Desktop</strong>: A full navigation menu (<code>#desktop-nav</code>) is visible. A mobile hamburger toggle (<code>#mobile-nav-toggle</code>) is hidden.</li>
<li><strong>Tablet</strong>: Similar to desktop, but perhaps with slightly different spacing (which we might not test here for simplicity, focusing on visibility).</li>
<li><strong>Mobile</strong>: The full navigation menu (<code>#desktop-nav</code>) is hidden. The mobile hamburger toggle (<code>#mobile-nav-toggle</code>) is visible.</li>
</ul>
<p>We can define our viewports as a list of tuples, where each tuple contains a descriptive name, width, and height.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># File: tests/e2e/test_responsive_homepage.py</span>

<span class="token keyword">import</span> pytest
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page<span class="token punctuation">,</span> expect

<span class="token comment"># Define our standard viewports</span>
<span class="token comment"># Each tuple: (name, width, height)</span>
VIEWPORTS <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"desktop"</span><span class="token punctuation">,</span> <span class="token number">1920</span><span class="token punctuation">,</span> <span class="token number">1080</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"tablet"</span><span class="token punctuation">,</span> <span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">,</span> <span class="token number">375</span><span class="token punctuation">,</span> <span class="token number">667</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>django_db</span>
<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize</span><span class="token punctuation">(</span><span class="token string">"viewport_name, width, height"</span><span class="token punctuation">,</span> VIEWPORTS<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">test_homepage_navigation_visibility</span><span class="token punctuation">(</span>
    page<span class="token punctuation">:</span> Page<span class="token punctuation">,</span> live_server<span class="token punctuation">,</span> viewport_name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> width<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token builtin">int</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>set_viewport_size<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"width"</span><span class="token punctuation">:</span> width<span class="token punctuation">,</span> <span class="token string">"height"</span><span class="token punctuation">:</span> height<span class="token punctuation">}</span><span class="token punctuation">)</span>
    page<span class="token punctuation">.</span>goto<span class="token punctuation">(</span>live_server<span class="token punctuation">.</span>url <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token comment"># Assuming your homepage is at the root</span>

    desktop_nav <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#desktop-nav"</span><span class="token punctuation">)</span>
    mobile_nav_toggle <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#mobile-nav-toggle"</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> viewport_name <span class="token operator">==</span> <span class="token string">"mobile"</span><span class="token punctuation">:</span>
        expect<span class="token punctuation">(</span>desktop_nav<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>
        expect<span class="token punctuation">(</span>mobile_nav_toggle<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># desktop and tablet</span>
        expect<span class="token punctuation">(</span>desktop_nav<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
        expect<span class="token punctuation">(</span>mobile_nav_toggle<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># You could add a screenshot for visual verification during debugging or for each viewport</span>
    <span class="token comment"># page.screenshot(path=f"screenshot_homepage_{viewport_name}.png")</span>
</code></pre>
<p>Let's dissect this responsive test:</p>
<ol>
<li><strong><code>import pytest</code></strong>, <strong><code>from playwright.sync_api import Page, expect</code></strong>: Standard imports for Pytest and Playwright.</li>
<li><strong><code>VIEWPORTS = [...]</code></strong>:
<ul>
<li>This list defines the different viewport configurations we want to test. Each item is a tuple: <code>(viewport_name_str, width_int, height_int)</code>.</li>
<li>Using a descriptive <code>viewport_name</code> like "desktop", "tablet", or "mobile" is good practice. It makes the test logic clearer and helps in identifying which parameterized run failed if an issue occurs.</li>
</ul>
</li>
<li><strong><code>@pytest.mark.django_db</code></strong>: This marker ensures that a test database is set up for this test, which is standard practice for Django E2E tests, even if this specific test doesn't directly interact with models. It ensures a consistent testing environment.</li>
<li><strong><code>@pytest.mark.parametrize("viewport_name, width, height", VIEWPORTS)</code></strong>:
<ul>
<li>This is our parameterization decorator.</li>
<li><code>"viewport_name, width, height"</code>: These are the argument names that will be passed to our test function.</li>
<li><code>VIEWPORTS</code>: The list we defined earlier, providing the actual values for each test run. Pytest will iterate through <code>VIEWPORTS</code>, and for each tuple (e.g., <code>("desktop", 1920, 1080)</code>), it will call <code>test_homepage_navigation_visibility</code> with <code>viewport_name="desktop"</code>, <code>width=1920</code>, and <code>height=1080</code>.</li>
</ul>
</li>
<li><strong><code>def test_homepage_navigation_visibility(...)</code></strong>:
<ul>
<li>The test function now accepts <code>page</code>, <code>live_server</code> (standard fixtures for Playwright E2E tests with Django) and our parameterized arguments: <code>viewport_name</code>, <code>width</code>, and <code>height</code>.</li>
<li>The type hints (<code>viewport_name: str, width: int, height: int</code>) are good practice for clarity.</li>
</ul>
</li>
<li><strong><code>page.set_viewport_size({"width": width, "height": height})</code></strong>:
<ul>
<li>Here, we use the <code>width</code> and <code>height</code> parameters received from <code>parametrize</code> to set the browser's viewport for the current test run. This is the crucial step that makes each parameterized run test a different screen size.</li>
</ul>
</li>
<li><strong><code>page.goto(live_server.url + "/")</code></strong>: Navigates to the homepage of our Django application running on the <code>live_server</code>.</li>
<li><strong><code>desktop_nav = page.locator("#desktop-nav")</code></strong> and <strong><code>mobile_nav_toggle = page.locator("#mobile-nav-toggle")</code></strong>: We get locators for the elements whose visibility we want to check. We assume these IDs exist in your HTML.</li>
<li><strong><code>if viewport_name == "mobile": ... else: ...</code></strong>:
<ul>
<li>This conditional logic uses the <code>viewport_name</code> parameter to apply different assertions based on the expected behavior for that viewport.</li>
<li>For "mobile", we expect the desktop navigation to be hidden and the mobile toggle to be visible.</li>
<li>For other viewports (implicitly "desktop" and "tablet" in this example), we expect the opposite.</li>
<li>This demonstrates how parameterization can be combined with conditional logic within the test to handle varying expectations across scenarios.</li>
</ul>
</li>
<li><strong><code>expect(desktop_nav).to_be_hidden()</code> / <code>to_be_visible()</code></strong>: These are Playwright's assertions checking the visibility state of the elements.</li>
<li><strong><code># page.screenshot(...)</code></strong>: This commented-out line shows how you could easily generate a screenshot for each viewport, which can be invaluable for debugging or visual regression testing. The parameterized <code>viewport_name</code> makes naming these screenshots straightforward.</li>
</ol>
<p><strong>Mental Model: Test Generation</strong></p>
<p>When Pytest encounters the <code>test_homepage_navigation_visibility</code> function decorated with <code>@pytest.mark.parametrize</code> and our <code>VIEWPORTS</code> list, it doesn't just run the function once. Instead, it effectively creates and runs three distinct test cases internally:</p>
<ol>
<li><strong>Test Case 1 (Desktop):</strong>
<ul>
<li><code>viewport_name = "desktop"</code></li>
<li><code>width = 1920</code></li>
<li><code>height = 1080</code></li>
<li>The test logic runs with these values.</li>
</ul>
</li>
<li><strong>Test Case 2 (Tablet):</strong>
<ul>
<li><code>viewport_name = "tablet"</code></li>
<li><code>width = 768</code></li>
<li><code>height = 1024</code></li>
<li>The test logic runs with these values.</li>
</ul>
</li>
<li><strong>Test Case 3 (Mobile):</strong>
<ul>
<li><code>viewport_name = "mobile"</code></li>
<li><code>width = 375</code></li>
<li><code>height = 667</code></li>
<li>The test logic runs with these values.</li>
</ul>
</li>
</ol>
<p>Each of these is treated as an independent test. If the assertions for the "mobile" viewport fail, but "desktop" and "tablet" pass, your test report will clearly indicate:
<code>test_responsive_homepage.py::test_homepage_navigation_visibility[mobile-375-667] FAILED</code>
<code>test_responsive_homepage.py::test_homepage_navigation_visibility[desktop-1920-1080] PASSED</code>
<code>test_responsive_homepage.py::test_homepage_navigation_visibility[tablet-768-1024] PASSED</code></p>
<p>This granularity is a significant advantage over trying to loop through viewports within a single test function, where a failure might be harder to isolate to a specific viewport.</p>
<p><strong>Benefits Revisited in Context</strong></p>
<p>Using <code>@pytest.mark.parametrize</code> for responsive testing offers clear advantages:</p>
<ul>
<li><strong>DRY Code</strong>: The core logic of navigating to the page and locating elements is written only once.</li>
<li><strong>Clear Definition of Scenarios</strong>: The <code>VIEWPORTS</code> list at the top explicitly documents all the screen sizes you are targeting.</li>
<li><strong>Easy Maintenance</strong>:
<ul>
<li>Need to test a new screen size (e.g., a larger mobile phone)? Just add another tuple to the <code>VIEWPORTS</code> list.</li>
<li>Does the URL or a common locator change? Update it in one place in the test function.</li>
</ul>
</li>
<li><strong>Targeted Debugging</strong>: Failures are reported per viewport, making it easy to identify which specific responsive layout has an issue.</li>
</ul>
<p><strong>Practical Considerations and Best Practices</strong></p>
<ul>
<li>
<p><strong>Descriptive Parameter Names</strong>: Use clear names in your <code>VIEWPORTS</code> list (like "mobile_small", "tablet_portrait") and in the <code>parametrize</code> string. If you only parameterize width and height, Pytest will generate names like <code>test_my_function[375-667]</code>. Adding a <code>viewport_name</code> parameter makes it <code>test_my_function[mobile-375-667]</code>, which is more readable.</p>
</li>
<li>
<p><strong>Keep Parameter Sets Manageable</strong>: While powerful, avoid over-complicating a single test with too many parameters if it makes the test logic convoluted. Sometimes, a separate, more specialized test might be clearer.</p>
</li>
<li>
<p><strong>Test Execution Time</strong>: Remember that each parameter set generates a full test run. For E2E tests, which can be slower, parameterizing across many viewports will increase the total execution time of your test suite. Prioritize the most critical breakpoints.</p>
</li>
<li>
<p><strong>Using <code>pytest.param</code> for More Control (Advanced)</strong>: For more complex scenarios, you can use <code>pytest.param</code> within your list of argument values. This allows you to set custom test IDs for parameterized tests or mark certain parameter sets (e.g., with <code>pytest.mark.xfail</code> if a specific viewport is known to have issues). For most responsive testing, simple tuples are sufficient.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># Example using pytest.param (for illustration, not strictly needed for basic viewports)</span>
<span class="token comment"># VIEWPORTS = [</span>
<span class="token comment">#     pytest.param("desktop", 1920, 1080, id="Desktop-HD"),</span>
<span class="token comment">#     pytest.param("mobile", 375, 667, id="Mobile-iPhoneX")</span>
<span class="token comment"># ]</span>
</code></pre>
</li>
</ul>
<p>By leveraging <code>@pytest.mark.parametrize</code>, you transform the challenge of testing multiple viewports from a repetitive chore into a structured and maintainable process. This technique is fundamental to building a comprehensive and robust responsive testing strategy for your Django applications. It ensures that your application not only works but also provides a great user experience across the diverse range of devices your users might employ.</p>
<h3 id="153-strategies-checking-different-locators-asserting-visibility-within-context" tabindex="-1"><a class="anchor" href="#153-strategies-checking-different-locators-asserting-visibility-within-context" name="153-strategies-checking-different-locators-asserting-visibility-within-context" tabindex="-1"><span class="octicon octicon-link"></span></a>15.3 Strategies: Checking Different Locators, Asserting Visibility within Context</h3>
<p>In the previous sections, we learned how to set different viewport sizes (15.1) and parameterize our tests to run against multiple breakpoints (15.2). These are foundational steps for testing responsive design. However, true responsive design often involves more than just elements resizing; it frequently means that:</p>
<ol>
<li>Different HTML elements are used to present the same information or functionality at different screen sizes.</li>
<li>The same HTML elements might be present in the DOM, but their visibility changes based on the viewport.</li>
</ol>
<p>This section delves into strategies for effectively testing these common responsive patterns. We'll explore how to check for alternative locators and how to assert visibility based on the current viewport context, ensuring your application delivers the correct experience on any device.</p>
<h4 id="strategy-1-checking-for-different-locators-based-on-viewport" tabindex="-1"><a class="anchor" href="#strategy-1-checking-for-different-locators-based-on-viewport" name="strategy-1-checking-for-different-locators-based-on-viewport" tabindex="-1"><span class="octicon octicon-link"></span></a>Strategy 1: Checking for Different Locators Based on Viewport</h4>
<p>One common responsive design pattern is to render entirely different HTML structures for different screen sizes. For example, a complex navigation menu on a desktop might be replaced by a simpler "hamburger" menu icon on mobile. In such cases, the locator for the "menu" functionality will change.</p>
<p><strong>The "Why": Optimizing User Experience</strong></p>
<p>Web developers employ this strategy to tailor the user interface (UI) and user experience (UX) to the specific constraints and interaction models of different devices. A full-fledged desktop navigation bar would be cumbersome on a small mobile screen, while a hamburger menu on a large desktop might hide readily accessible options. Your tests need to verify that the <em>intended</em> element for the current viewport is present and functional.</p>
<p><strong>The "How": Conditional Locator Checks</strong></p>
<p>When your test is parameterized with viewport information (as discussed in 15.2), you can use this information to decide which locator to expect.</p>
<p>Let's consider a simple Django application with a <code>responsive_app</code> and a template that shows different content for mobile and desktop.</p>
<p><strong>1. Example Django Template (<code>responsive_app/templates/responsive_app/content.html</code>)</strong></p>
<p>First, let's create a template that renders different elements based on some (simulated) context or CSS. For simplicity in this example, we'll just put both elements in the HTML and rely on CSS (which we'll imagine exists) to show/hide them. Our test will then verify the correct one is <em>visible</em>.</p>
<pre class="language-html" tabindex="0"><code class="language-html"><span class="token comment">&lt;!-- THIS_CODE_SNIPPET --&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Responsive Content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token comment">/* Imagine these classes are controlled by media queries */</span>
        <span class="token selector">.mobile-only</span> <span class="token punctuation">{</span> <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/* Hidden by default, shown on mobile */</span>
        <span class="token selector">.desktop-only</span> <span class="token punctuation">{</span> <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/* Shown by default, hidden on mobile */</span>

        <span class="token comment">/* Example media query (conceptual for this HTML, real would be in CSS file)
        @media (max-width: 600px) {
            .mobile-only { display: block; }
            .desktop-only { display: none; }
        }
        */</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Our Responsive Page<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mobile-only<span class="token punctuation">"</span></span> <span class="token attr-name">data-testid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mobile-header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>Mobile Header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This content is optimized for mobile viewing.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>desktop-only<span class="token punctuation">"</span></span> <span class="token attr-name">data-testid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>desktop-header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>Desktop Header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This content is designed for larger desktop screens.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Let's examine this HTML structure:</p>
<ol>
<li><strong><code>&lt;!DOCTYPE html&gt;...&lt;body&gt;</code></strong>: Standard HTML boilerplate.</li>
<li><strong><code>&lt;style&gt;</code> block</strong>:
<ul>
<li>This block contains simplified CSS rules. In a real application, these responsive styles would typically reside in external CSS files and use media queries (e.g., <code>@media (max-width: 600px)</code>).</li>
<li><code>.mobile-only { display: none; }</code>: Elements with this class are initially hidden.</li>
<li><code>.desktop-only { display: block; }</code>: Elements with this class are initially visible.</li>
<li>The commented-out media query illustrates how CSS would typically swap visibility. For our testing purpose, we'll assume the CSS correctly applies these styles based on the viewport.</li>
</ul>
</li>
<li><strong><code>&lt;div class="mobile-only" data-testid="mobile-header"&gt;</code></strong>:
<ul>
<li>This <code>div</code> is intended for mobile viewports.</li>
<li>It has a <code>data-testid="mobile-header"</code> attribute, which provides a stable way for our tests to locate it.</li>
</ul>
</li>
<li><strong><code>&lt;div class="desktop-only" data-testid="desktop-header"&gt;</code></strong>:
<ul>
<li>This <code>div</code> is intended for desktop viewports.</li>
<li>It has a <code>data-testid="desktop-header"</code> attribute for stable test location.</li>
</ul>
</li>
</ol>
<p>The key idea is that, due to CSS media queries (which we are simulating the effect of), only one of these <code>div</code> blocks should be visible at any given time, depending on the screen width.</p>
<p><strong>2. Example Django View (<code>responsive_app/views.py</code>)</strong></p>
<p>A simple view to render this template:</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># responsive_app/views.py</span>
<span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render

<span class="token keyword">def</span> <span class="token function">responsive_content_view</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'responsive_app/content.html'</span><span class="token punctuation">)</span>
</code></pre>
<p>This is a standard Django view function:</p>
<ol>
<li><code>from django.shortcuts import render</code>: Imports the <code>render</code> shortcut.</li>
<li><code>def responsive_content_view(request):</code>: Defines the view function.</li>
<li><code>return render(request, 'responsive_app/content.html')</code>: Renders the <code>content.html</code> template we defined earlier.</li>
</ol>
<p><strong>3. Example Django URLs (<code>responsive_app/urls.py</code> and project <code>urls.py</code>)</strong></p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># responsive_app/urls.py</span>
<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> views

urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>
    path<span class="token punctuation">(</span><span class="token string">'responsive/'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>responsive_content_view<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'responsive_content'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># project/urls.py</span>
<span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin
<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span> include

urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>
    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>
    path<span class="token punctuation">(</span><span class="token string">'app/'</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'responsive_app.urls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment"># Include your app's URLs</span>
<span class="token punctuation">]</span>
</code></pre>
<p>These files set up the URL routing:</p>
<ul>
<li><code>responsive_app/urls.py</code>: Defines a URL pattern for our app. <code>/responsive/</code> will map to <code>responsive_content_view</code>.</li>
<li><code>project/urls.py</code>: Includes the <code>responsive_app.urls</code> under the <code>/app/</code> prefix. So, the full URL will be <code>/app/responsive/</code>.</li>
</ul>
<p><strong>4. The Test (<code>tests/test_responsive_content.py</code>)</strong></p>
<p>Now, let's write a <code>pytest-playwright</code> test that checks for the correct header based on the viewport. We'll use parameterization as discussed in section 15.2.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># tests/test_responsive_content.py</span>
<span class="token keyword">import</span> pytest
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page<span class="token punctuation">,</span> expect

<span class="token comment"># Define viewports: (name, width, height, expected_mobile_visible, expected_desktop_visible)</span>
VIEWPORTS <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">,</span> <span class="token number">360</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"desktop"</span><span class="token punctuation">,</span> <span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize</span><span class="token punctuation">(</span><span class="token string">"name,width,height,mobile_visible,desktop_visible"</span><span class="token punctuation">,</span> VIEWPORTS<span class="token punctuation">)</span>
<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>django_db</span> <span class="token comment"># Not strictly needed for this example if no DB interaction, but good practice</span>
<span class="token keyword">def</span> <span class="token function">test_responsive_header_visibility</span><span class="token punctuation">(</span>
    page<span class="token punctuation">:</span> Page<span class="token punctuation">,</span>
    live_server<span class="token punctuation">,</span>
    name<span class="token punctuation">,</span>
    width<span class="token punctuation">,</span>
    height<span class="token punctuation">,</span>
    mobile_visible<span class="token punctuation">,</span>
    desktop_visible
<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>set_viewport_size<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"width"</span><span class="token punctuation">:</span> width<span class="token punctuation">,</span> <span class="token string">"height"</span><span class="token punctuation">:</span> height<span class="token punctuation">}</span><span class="token punctuation">)</span>
    page<span class="token punctuation">.</span>goto<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>live_server<span class="token punctuation">.</span>url<span class="token punctuation">}</span></span><span class="token string">/app/responsive/"</span></span><span class="token punctuation">)</span>

    mobile_header <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"[data-testid='mobile-header']"</span><span class="token punctuation">)</span>
    desktop_header <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"[data-testid='desktop-header']"</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> mobile_visible<span class="token punctuation">:</span>
        expect<span class="token punctuation">(</span>mobile_header<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Viewport </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token punctuation">{</span>height<span class="token punctuation">}</span></span><span class="token string">): Mobile header visible (as expected)."</span></span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        expect<span class="token punctuation">(</span>mobile_header<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Viewport </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token punctuation">{</span>height<span class="token punctuation">}</span></span><span class="token string">): Mobile header hidden (as expected)."</span></span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> desktop_visible<span class="token punctuation">:</span>
        expect<span class="token punctuation">(</span>desktop_header<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Viewport </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token punctuation">{</span>height<span class="token punctuation">}</span></span><span class="token string">): Desktop header visible (as expected)."</span></span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        expect<span class="token punctuation">(</span>desktop_header<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Viewport </span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span><span class="token string">x</span><span class="token interpolation"><span class="token punctuation">{</span>height<span class="token punctuation">}</span></span><span class="token string">): Desktop header hidden (as expected)."</span></span><span class="token punctuation">)</span>

</code></pre>
<p>Let's break down this test file:</p>
<ol>
<li>
<p><strong><code>import pytest ...</code></strong>: Imports necessary modules.</p>
</li>
<li>
<p><strong><code>VIEWPORTS = [...]</code></strong>:</p>
<ul>
<li>This list defines our test cases for parameterization. Each tuple contains:
<ul>
<li><code>name</code>: A descriptive name for the viewport (e.g., "mobile", "desktop").</li>
<li><code>width</code>, <code>height</code>: The dimensions of the viewport.</li>
<li><code>mobile_visible</code>: A boolean indicating whether the mobile header is expected to be visible at this viewport.</li>
<li><code>desktop_visible</code>: A boolean indicating whether the desktop header is expected to be visible.</li>
</ul>
</li>
<li>This structure allows us to clearly define expectations for each viewport size.</li>
</ul>
</li>
<li>
<p><strong><code>@pytest.mark.parametrize(...)</code></strong>:</p>
<ul>
<li>This decorator tells <code>pytest</code> to run the <code>test_responsive_header_visibility</code> function multiple times, once for each entry in the <code>VIEWPORTS</code> list.</li>
<li>The arguments to the test function (<code>name</code>, <code>width</code>, <code>height</code>, etc.) will be populated from the tuples in <code>VIEWPORTS</code>.</li>
</ul>
</li>
<li>
<p><strong><code>@pytest.mark.django_db</code></strong>:</p>
<ul>
<li>While our current example doesn't directly interact with the database for this specific test, it's often good practice to include it if your views <em>might</em> involve database access, or if other tests in the same file do. It ensures the test database is set up.</li>
</ul>
</li>
<li>
<p><strong><code>def test_responsive_header_visibility(...)</code></strong>:</p>
<ul>
<li>The test function itself, accepting <code>page</code>, <code>live_server</code>, and the parameterized values.</li>
</ul>
</li>
<li>
<p><strong><code>page.set_viewport_size({"width": width, "height": height})</code></strong>:</p>
<ul>
<li>Sets the browser viewport to the dimensions specified by the current parameter set. This is crucial for simulating different devices.</li>
</ul>
</li>
<li>
<p><strong><code>page.goto(f"{live_server.url}/app/responsive/")</code></strong>:</p>
<ul>
<li>Navigates the Playwright-controlled browser to the URL of our responsive content page, served by the <code>live_server</code>.</li>
</ul>
</li>
<li>
<p><strong><code>mobile_header = page.locator("[data-testid='mobile-header']")</code></strong>:</p>
<ul>
<li>Creates a Playwright <code>Locator</code> object for the mobile header element using its <code>data-testid</code>. This doesn't perform any action yet; it just defines how to find the element.</li>
<li>We use <code>data-testid</code> because it's a good practice for creating stable test selectors that are decoupled from CSS class names or complex DOM structures that might change for styling reasons.</li>
</ul>
</li>
<li>
<p><strong><code>desktop_header = page.locator("[data-testid='desktop-header']")</code></strong>:</p>
<ul>
<li>Similarly, creates a <code>Locator</code> for the desktop header.</li>
</ul>
</li>
<li>
<p><strong><code>if mobile_visible:</code> / <code>else:</code> block</strong>:</p>
<ul>
<li>This conditional logic checks the <code>mobile_visible</code> boolean from our <code>VIEWPORTS</code> data.</li>
<li><strong><code>expect(mobile_header).to_be_visible()</code></strong>: If <code>mobile_visible</code> is <code>True</code>, this assertion checks that the element located by <code>mobile_header</code> is actually visible on the page. Playwright's <code>expect</code> comes with auto-waiting, so it will wait for a short period for the element to become visible if it's not immediately so.</li>
<li><strong><code>expect(mobile_header).to_be_hidden()</code></strong>: If <code>mobile_visible</code> is <code>False</code>, this assertion checks that the element is <em>not</em> visible (e.g., <code>display: none</code>, <code>visibility: hidden</code>, zero size, or not in DOM).</li>
<li>The <code>print</code> statements are for illustrative purposes to see the test flow during execution (you might remove them in a production test suite or use <code>pytest</code>'s verbose mode).</li>
</ul>
</li>
<li>
<p><strong><code>if desktop_visible:</code> / <code>else:</code> block</strong>:</p>
<ul>
<li>This performs the same visibility checks for the <code>desktop_header</code> based on the <code>desktop_visible</code> expectation.</li>
</ul>
</li>
</ol>
<p><strong>Running the Test</strong></p>
<p>When you run <code>pytest</code>, it will execute <code>test_responsive_header_visibility</code> twice:</p>
<ul>
<li>Once with "mobile" parameters: It will set the viewport to 360x640, navigate to the page, and assert that the mobile header is visible and the desktop header is hidden.</li>
<li>Once with "desktop" parameters: It will set the viewport to 1280x720, navigate, and assert that the mobile header is hidden and the desktop header is visible.</li>
</ul>
<p>This strategy effectively verifies that your application presents the correct UI components for different device contexts by checking for the visibility of distinct locators.</p>
<h4 id="strategy-2-asserting-visibility-of-the-same-locator-within-different-contexts" tabindex="-1"><a class="anchor" href="#strategy-2-asserting-visibility-of-the-same-locator-within-different-contexts" name="strategy-2-asserting-visibility-of-the-same-locator-within-different-contexts" tabindex="-1"><span class="octicon octicon-link"></span></a>Strategy 2: Asserting Visibility of the Same Locator within Different Contexts</h4>
<p>Sometimes, the same HTML element (or a component represented by a consistent locator like <code>data-testid</code>) remains in the DOM across different viewports, but its visibility is toggled using CSS (e.g., <code>display: none;</code> vs. <code>display: block;</code> controlled by media queries).</p>
<p><strong>The "Why": Simpler DOM, CSS-Driven Changes</strong></p>
<p>This approach can lead to a simpler DOM structure, as you're not swapping out entire chunks of HTML. The responsiveness is handled primarily by CSS rules. Your tests need to confirm that these CSS rules are correctly applied and result in the intended visibility state.</p>
<p><strong>The "How": <code>expect(...).to_be_visible()</code> and <code>expect(...).to_be_hidden()</code></strong></p>
<p>This is precisely what we demonstrated in the example above. The core idea is:</p>
<ol>
<li>Identify the element(s) whose visibility changes.</li>
<li>For each viewport size you're testing:
<ul>
<li>Assert <code>expect(locator).to_be_visible()</code> if the element should be seen.</li>
<li>Assert <code>expect(locator).to_be_hidden()</code> if the element should not be seen.</li>
</ul>
</li>
</ol>
<p><strong>Mental Model: The CSS Switch</strong></p>
<p>Think of CSS media queries as switches that toggle the visibility of elements. Your Playwright test acts as an inspector, verifying that these switches are in the correct position for the current viewport size. <code>to_be_visible()</code> checks if the "light" is on, and <code>to_be_hidden()</code> checks if it's off.</p>
<p><strong>Revisiting the Code Example</strong></p>
<p>Our previous code example (<code>tests/test_responsive_content.py</code>) already perfectly implements this strategy.</p>
<ul>
<li>We have two distinct locators: <code>mobile_header</code> and <code>desktop_header</code>.</li>
<li>For each viewport defined in <code>VIEWPORTS</code>, we explicitly assert the expected visibility state (<code>to_be_visible()</code> or <code>to_be_hidden()</code>) for <em>both</em> locators.</li>
</ul>
<p>This comprehensive check ensures that:</p>
<ul>
<li>The element intended for the current viewport <em>is</em> visible.</li>
<li>The element(s) intended for <em>other</em> viewports are <em>not</em> visible.</li>
</ul>
<p>This second part is crucial. Simply checking that the mobile header is visible on a mobile viewport isn't enough; you also need to confirm that the desktop header (or other non-mobile elements) are correctly hidden. Otherwise, you might have overlapping or broken layouts.</p>
<p><strong>Variations and Edge Cases:</strong></p>
<ul>
<li><strong>Elements that change content but not locator:</strong> Sometimes, an element (e.g., a <code>&lt;span&gt;</code> with a <code>data-testid</code>) might change its text content based on viewport size. You'd use <code>expect(locator).to_have_text("Expected mobile text")</code> or <code>expect(locator).to_have_text("Expected desktop text")</code>.</li>
<li><strong>Elements that change attributes:</strong> An <code>&lt;img&gt;</code> tag might change its <code>src</code> attribute. You'd use <code>expect(locator).to_have_attribute("src", "mobile-image.jpg")</code>.</li>
<li><strong>Focus on what the user experiences:</strong> If a "button" is implemented as an <code>&lt;a&gt;</code> tag on desktop and a <code>&lt;button&gt;</code> tag on mobile, but both have the text "Submit", you might prefer <code>page.locator("text=Submit")</code> if that's unique enough, or use role locators like <code>page.get_by_role("button", name="Submit")</code>. If their roles or text differ, then checking distinct locators is more appropriate.</li>
</ul>
<h4 id="integrating-strategies-with-parameterization" tabindex="-1"><a class="anchor" href="#integrating-strategies-with-parameterization" name="integrating-strategies-with-parameterization" tabindex="-1"><span class="octicon octicon-link"></span></a>Integrating Strategies with Parameterization</h4>
<p>As demonstrated in <code>tests/test_responsive_content.py</code>, parameterization using <code>@pytest.mark.parametrize</code> is the key to efficiently applying these strategies across multiple viewports.</p>
<p>By defining your viewports and their expected outcomes (which elements are visible/hidden, which locators to use) in a data structure like the <code>VIEWPORTS</code> list, you can write a single, concise test function that covers numerous responsive scenarios.</p>
<p>This approach offers several benefits:</p>
<ol>
<li><strong>Readability</strong>: The expected behavior for each viewport is clearly laid out.</li>
<li><strong>Maintainability</strong>: If a new breakpoint is introduced or behavior changes, you primarily update the <code>VIEWPORTS</code> data structure.</li>
<li><strong>Coverage</strong>: Easily test a wide range of screen sizes.</li>
</ol>
<h4 id="best-practices-and-considerations-for-responsive-testing" tabindex="-1"><a class="anchor" href="#best-practices-and-considerations-for-responsive-testing" name="best-practices-and-considerations-for-responsive-testing" tabindex="-1"><span class="octicon octicon-link"></span></a>Best Practices and Considerations for Responsive Testing</h4>
<ol>
<li>
<p><strong>Prioritize User-Facing Locators</strong>: Whenever possible, use locators that reflect how a user perceives the page (role, text, label, placeholder). This makes tests more resilient to underlying HTML structure changes that don't affect the user experience. However, when elements are fundamentally different (like a hamburger icon vs. a nav bar), distinct, stable locators (like <code>data-testid</code>) for each version are necessary.</p>
</li>
<li>
<p><strong>Test the <em>Outcome</em>, Not (Just) the Implementation</strong>:</p>
<ul>
<li>Focus on whether the correct information is displayed and functional at a given viewport. For example, is the "Login" button visible and clickable?</li>
<li>Avoid overly relying on specific CSS classes for locators if those classes are purely stylistic and likely to change. <code>data-testid</code> attributes are generally more stable for testing purposes.</li>
</ul>
</li>
<li>
<p><strong>Use <code>to_be_hidden()</code> Deliberately</strong>: Don't just check that the "mobile menu" is visible on small screens. Also check that the "desktop navigation bar" is <em>hidden</em>. This prevents issues where both might be accidentally rendered.</p>
</li>
<li>
<p><strong><code>data-testid</code> for Logical Components</strong>: If a logical component (e.g., "user profile link") is implemented with different HTML structures at different breakpoints, consider if a common <code>data-testid</code> on the <em>visible instance</em> makes sense, or if distinct <code>data-testid</code>s (e.g., <code>data-testid="mobile-profile-link"</code> and <code>data-testid="desktop-profile-link"</code>) are clearer. The latter is often better when the elements are truly different.</p>
</li>
<li>
<p><strong>Don't Over-Test Every Breakpoint</strong>: Identify the key breakpoints where your layout or component visibility <em>actually changes</em>. Testing every minor CSS adjustment breakpoint is usually unnecessary and leads to brittle tests. Focus on the points where distinct user experiences are presented.</p>
</li>
<li>
<p><strong>Combine with Visual Regression Testing (Advanced)</strong>: For complex visual layouts, automated visual regression testing (covered briefly later) can complement these functional checks by detecting unintended visual changes.</p>
</li>
</ol>
<p>By employing these strategiesâ€”checking for different locators when structures change, and asserting visibility/hidden states for elements controlled by CSSâ€”you can build a robust suite of tests that give you high confidence in your application's responsive design. Parameterization makes these checks efficient and manageable, allowing you to verify the user experience across a spectrum of devices.</p>
<h3 id="154-detecting-layout-issues-overflow-checks-bounding-box-comparisons" tabindex="-1"><a class="anchor" href="#154-detecting-layout-issues-overflow-checks-bounding-box-comparisons" name="154-detecting-layout-issues-overflow-checks-bounding-box-comparisons" tabindex="-1"><span class="octicon octicon-link"></span></a>15.4 Detecting Layout Issues (Overflow Checks, Bounding Box Comparisons)</h3>
<p>While Playwright's visibility assertions like <code>expect(locator).to_be_visible()</code> are excellent for confirming an element is present in the DOM and not explicitly hidden, they don't tell the whole story about an element's visual presentation. An element might be "visible" but still contribute to a broken layout: it could be overlapping other crucial elements, overflowing its container, or positioned incorrectly, especially across different screen sizes. These are common responsive design bugs. This section delves into programmatic techniques to detect such layout issues.</p>
<p><strong>The Limitations of Basic Visibility Checks</strong></p>
<p>Imagine a scenario: a "Submit" button is technically visible on a mobile screen, but a misconfigured cookie banner partially overlaps it, making it unclickable. Or, important product information is truncated within a container that has <code>overflow: hidden</code> due to a CSS miscalculation on smaller viewports. <code>expect(button_locator).to_be_visible()</code> would pass in both cases, yet the user experience is compromised. To catch these, we need to inspect the geometry and rendering properties of elements.</p>
<p><strong>1. Bounding Box Comparisons: Understanding Element Geometry</strong></p>
<p>Every element rendered on a webpage occupies a rectangular space. This is known as its <strong>bounding box</strong>. This box is defined by its top-left coordinates (x, y) relative to the viewport, and its width and height. Playwright allows us to retrieve these geometric properties, which we can then use to make assertions about element positioning and potential overlaps.</p>
<p><strong>What is a Bounding Box?</strong></p>
<p>Think of it as the smallest rectangle enclosing the element, including its padding and border, but not its margin (this aligns with the <code>getBoundingClientRect()</code> DOM API, which is what Playwright typically uses under the hood). The properties are:</p>
<ul>
<li><code>x</code>: The X-coordinate of the top-left corner of the element, relative to the viewport.</li>
<li><code>y</code>: The Y-coordinate of the top-left corner of the element, relative to the viewport.</li>
<li><code>width</code>: The width of the element.</li>
<li><code>height</code>: The height of the element.</li>
</ul>
<p>Knowing these values for multiple elements allows us to calculate if they overlap, if one contains another, or if an element has an unexpected size (e.g., zero width or height when it should be visible).</p>
<p><strong>Retrieving Bounding Boxes with Playwright</strong></p>
<p>The <code>element_handle.bounding_box()</code> method is our tool for this:</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># (Conceptual - assume 'element' is a Playwright ElementHandle)</span>
<span class="token comment"># element_box = element.bounding_box()</span>
<span class="token comment"># if element_box:</span>
<span class="token comment">#     print(f"X: {element_box['x']}, Y: {element_box['y']}")</span>
<span class="token comment">#     print(f"Width: {element_box['width']}, Height: {element_box['height']}")</span>
</code></pre>
<p>Let's examine this conceptual snippet:</p>
<ol>
<li><code>element.bounding_box()</code>: This method is called on an <code>ElementHandle</code> (which you get from a locator, e.g., <code>page.locator(...).element_handle()</code>).
<ul>
<li>It returns a dictionary containing <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>, or <code>None</code> if the element is not visible or not part of the layout (e.g., <code>display: none</code>).</li>
<li>The coordinates are relative to the main frame's viewport.</li>
</ul>
</li>
</ol>
<p><strong>Example 1: Detecting Overlapping Elements</strong></p>
<p>Let's say we have a critical call-to-action button and a notification banner. We want to ensure the banner doesn't overlap the button.</p>
<p><strong>Conceptual HTML/CSS:</strong></p>
<p>Imagine a page with this structure:</p>
<pre class="language-html" tabindex="0"><code class="language-html"><span class="token comment">&lt;!-- THIS_CODE_SNIPPET --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">#important-button</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token comment">/* For z-index context if needed */</span>
    <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">#notification-banner</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token comment">/* Potential for overlap */</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span> <span class="token comment">/* Intentionally positioned to overlap part of the button */</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">z-index</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span> <span class="token comment">/* Higher z-index means it will be on top */</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>important-button<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Click Me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>notification-banner<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Important Notice!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>In this setup, the <code>notification-banner</code> is styled to potentially overlap the <code>important-button</code>.</p>
<p><strong>Playwright Test:</strong></p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page<span class="token punctuation">,</span> expect

<span class="token keyword">def</span> <span class="token function">do_boxes_overlap</span><span class="token punctuation">(</span>box1<span class="token punctuation">,</span> box2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Check if one rectangle is to the left of the other</span>
    <span class="token keyword">if</span> box1<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">+</span> box1<span class="token punctuation">[</span><span class="token string">'width'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> box2<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token keyword">or</span> \
       box2<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">+</span> box2<span class="token punctuation">[</span><span class="token string">'width'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> box1<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token comment"># Check if one rectangle is above the other</span>
    <span class="token keyword">if</span> box1<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">+</span> box1<span class="token punctuation">[</span><span class="token string">'height'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> box2<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token keyword">or</span> \
       box2<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">+</span> box2<span class="token punctuation">[</span><span class="token string">'height'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> box1<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">def</span> <span class="token function">test_button_not_overlapped_by_banner</span><span class="token punctuation">(</span>page<span class="token punctuation">:</span> Page<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>set_content<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
        &lt;style&gt;
          body {{ margin: 20px; }} /* Add some margin for visual clarity */
          #important-button {{
            width: 150px; height: 50px;
            background-color: green; color: white;
            padding: 10px;
            position: relative; z-index: 1;
            top: 50px; left: 50px; /* Position button for test */
          }}
          #notification-banner {{
            width: 200px; height: 30px;
            background-color: yellow;
            position: absolute;
            /* Intentionally position banner to overlap the button */
            top: 60px; /* Button top is 50px + 10px padding, banner starts at 60px */
            left: 40px; /* Button left is 50px, banner starts at 40px */
            z-index: 2;
          }}
        &lt;/style&gt;
        &lt;div id="important-button"&gt;Click Me!&lt;/div&gt;
        &lt;div id="notification-banner"&gt;Important Notice!&lt;/div&gt;
    """</span><span class="token punctuation">)</span>

    button <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#important-button"</span><span class="token punctuation">)</span>
    banner <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#notification-banner"</span><span class="token punctuation">)</span>

    <span class="token comment"># Ensure elements are visible before getting bounding boxes</span>
    expect<span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
    expect<span class="token punctuation">(</span>banner<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>

    button_box <span class="token operator">=</span> button<span class="token punctuation">.</span>bounding_box<span class="token punctuation">(</span><span class="token punctuation">)</span>
    banner_box <span class="token operator">=</span> banner<span class="token punctuation">.</span>bounding_box<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">assert</span> button_box <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"Button should have a bounding box"</span>
    <span class="token keyword">assert</span> banner_box <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"Banner should have a bounding box"</span>

    <span class="token comment"># For the sake of this example, we expect them to overlap due to CSS</span>
    <span class="token comment"># In a real test, you'd assert they *don't* overlap if that's the requirement</span>
    <span class="token comment"># assert not do_boxes_overlap(button_box, banner_box), \</span>
    <span class="token comment">#    "Notification banner should not overlap the important button"</span>

    <span class="token comment"># Let's demonstrate the overlap detection</span>
    <span class="token comment"># (This assertion would fail if they didn't overlap)</span>
    <span class="token keyword">assert</span> do_boxes_overlap<span class="token punctuation">(</span>button_box<span class="token punctuation">,</span> banner_box<span class="token punctuation">)</span><span class="token punctuation">,</span> \
        <span class="token string">"Banner and button are expected to overlap in this example setup."</span>

    <span class="token comment"># To make this a corrective test, you'd adjust CSS and assert for no overlap:</span>
    <span class="token comment"># For example, if banner was at top: 10px, it wouldn't overlap.</span>
    <span class="token comment"># Then: assert not do_boxes_overlap(button_box, banner_box)</span>
</code></pre>
<p>Let's examine this code in detail:</p>
<ol>
<li>
<p><strong><code>do_boxes_overlap(box1, box2)</code> function</strong>:</p>
<ul>
<li>This is a helper function that takes two bounding box dictionaries (as returned by <code>bounding_box()</code>) as input.</li>
<li>It implements a standard algorithm to check for rectangle intersection. Two rectangles do <em>not</em> overlap if one is entirely to the left/right or entirely above/below the other. If none of these conditions are met, they overlap.</li>
<li>This logic is fundamental for geometric collision detection.</li>
</ul>
</li>
<li>
<p><strong><code>test_button_not_overlapped_by_banner(page: Page)</code></strong>:</p>
<ul>
<li><code>page.set_content(...)</code>: For this standalone example, we directly set the HTML content of the page. In a Django project, this HTML would typically be rendered by a view and template. The CSS is designed to make the banner overlap the button.</li>
<li><code>button = page.locator("#important-button")</code> and <code>banner = page.locator("#notification-banner")</code>: We get locators for the elements we want to inspect.</li>
<li><code>expect(button).to_be_visible()</code> and <code>expect(banner).to_be_visible()</code>: It's good practice to ensure elements are considered visible by Playwright before attempting to get their bounding boxes. An element that isn't visible won't have a meaningful bounding box.</li>
<li><code>button_box = button.bounding_box()</code> and <code>banner_box = banner.bounding_box()</code>: We retrieve the geometric properties of both elements.</li>
<li><code>assert button_box is not None</code> and <code>assert banner_box is not None</code>: We check that <code>bounding_box()</code> returned data, implying the elements are rendered.</li>
<li><code>assert do_boxes_overlap(button_box, banner_box), ...</code>: In this specific example, our CSS <em>causes</em> an overlap, so we assert that our <code>do_boxes_overlap</code> function correctly detects it.
<ul>
<li><strong>Crucially, in a real-world test where you want to <em>prevent</em> overlap, your assertion would be <code>assert not do_boxes_overlap(...)</code></strong>. You would design your CSS to avoid the overlap, and the test would verify this.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This example demonstrates how to programmatically check for overlaps. This is far more robust than relying solely on visual inspection or simple visibility checks, especially in automated CI/CD pipelines.</p>
<p><strong>Example 2: Detecting an Element Outside Its Container</strong></p>
<p>Sometimes, child elements can "break out" of their parent containers if CSS like <code>width</code>, <code>height</code>, or <code>position</code> is misconfigured.</p>
<p><strong>Conceptual HTML/CSS:</strong></p>
<pre class="language-html" tabindex="0"><code class="language-html"><span class="token comment">&lt;!-- THIS_CODE_SNIPPET --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">#container</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> lightblue<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token comment">/* Establishes a containing block */</span>
  <span class="token punctuation">}</span>
  <span class="token selector">#child-element</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> lightcoral<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 70px<span class="token punctuation">;</span> <span class="token comment">/* (100 - 50) / 2 = 25. 70px is too far down */</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span> <span class="token comment">/* (200 - 100) / 2 = 50. 150px is too far right */</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>child-element<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Child<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Here, <code>child-element</code> is positioned to be partially outside <code>container</code>.</p>
<p><strong>Playwright Test:</strong></p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page<span class="token punctuation">,</span> expect

<span class="token keyword">def</span> <span class="token function">is_box_contained</span><span class="token punctuation">(</span>child_box<span class="token punctuation">,</span> parent_box<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> child_box <span class="token keyword">or</span> <span class="token keyword">not</span> parent_box<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    
    <span class="token comment"># Check if child's top-left corner is within parent</span>
    is_top_left_inside <span class="token operator">=</span> <span class="token punctuation">(</span>child_box<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> parent_box<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token keyword">and</span>
                          child_box<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> parent_box<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    
    <span class="token comment"># Check if child's bottom-right corner is within parent</span>
    is_bottom_right_inside <span class="token operator">=</span> <span class="token punctuation">(</span>child_box<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">+</span> child_box<span class="token punctuation">[</span><span class="token string">'width'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> parent_box<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">+</span> parent_box<span class="token punctuation">[</span><span class="token string">'width'</span><span class="token punctuation">]</span> <span class="token keyword">and</span>
                              child_box<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">+</span> child_box<span class="token punctuation">[</span><span class="token string">'height'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> parent_box<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">+</span> parent_box<span class="token punctuation">[</span><span class="token string">'height'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> is_top_left_inside <span class="token keyword">and</span> is_bottom_right_inside

<span class="token keyword">def</span> <span class="token function">test_child_element_within_container</span><span class="token punctuation">(</span>page<span class="token punctuation">:</span> Page<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>set_content<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
        &lt;style&gt;
          body {{ margin: 20px; }}
          #container {{
            width: 200px; height: 100px;
            background-color: lightblue;
            border: 1px solid blue; /* Border contributes to visual size but not clientWidth/Height for box-sizing: content-box */
            position: relative; /* Important for absolute positioning context of child */
            top: 50px; left: 50px;
          }}
          #child-element {{
            width: 100px; height: 50px;
            background-color: lightcoral;
            position: absolute;
            /* Intentionally position child to be partially outside */
            top: 70px;  /* Container height 100px, child height 50px. Max top for containment is 50px. */
            left: 150px; /* Container width 200px, child width 100px. Max left for containment is 100px. */
          }}
        &lt;/style&gt;
        &lt;div id="container"&gt;
          &lt;div id="child-element"&gt;Child&lt;/div&gt;
        &lt;/div&gt;
    """</span><span class="token punctuation">)</span>

    container <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#container"</span><span class="token punctuation">)</span>
    child <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"#child-element"</span><span class="token punctuation">)</span>

    expect<span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>
    expect<span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>

    container_box <span class="token operator">=</span> container<span class="token punctuation">.</span>bounding_box<span class="token punctuation">(</span><span class="token punctuation">)</span>
    child_box <span class="token operator">=</span> child<span class="token punctuation">.</span>bounding_box<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">assert</span> container_box <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"Container should have a bounding box"</span>
    <span class="token keyword">assert</span> child_box <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"Child element should have a bounding box"</span>

    <span class="token comment"># In this setup, the child is outside. Our function should detect this.</span>
    <span class="token comment"># A real test would assert that it *is* contained after fixing CSS.</span>
    <span class="token comment"># assert is_box_contained(child_box, container_box), \</span>
    <span class="token comment">#    "Child element should be fully contained within the parent"</span>
    
    <span class="token keyword">assert</span> <span class="token keyword">not</span> is_box_contained<span class="token punctuation">(</span>child_box<span class="token punctuation">,</span> container_box<span class="token punctuation">)</span><span class="token punctuation">,</span> \
        <span class="token string">"Child element is expected to be outside the container in this example."</span>
</code></pre>
<p>Let's break down this test:</p>
<ol>
<li>
<p><strong><code>is_box_contained(child_box, parent_box)</code> function</strong>:</p>
<ul>
<li>This helper determines if <code>child_box</code> is entirely within <code>parent_box</code>.</li>
<li>It checks if the child's top-left <code>(x, y)</code> coordinates are greater than or equal to the parent's.</li>
<li>It also checks if the child's bottom-right <code>(x + width, y + height)</code> coordinates are less than or equal to the parent's.</li>
<li>Both conditions must be true for the child to be fully contained.</li>
</ul>
</li>
<li>
<p><strong><code>test_child_element_within_container(page: Page)</code></strong>:</p>
<ul>
<li><code>page.set_content(...)</code>: Again, we set up HTML with CSS designed to cause the layout issue. The <code>child-element</code> is positioned such that parts of it will extend beyond the <code>container</code>'s boundaries.</li>
<li>Locators and visibility checks are similar to the previous example.</li>
<li><code>container_box = container.bounding_box()</code> and <code>child_box = child.bounding_box()</code>: We fetch their geometric data.</li>
<li><code>assert not is_box_contained(child_box, container_box), ...</code>: For this example, we assert that the child is <em>not</em> contained, proving our detection logic.
<ul>
<li><strong>In a corrective test, you would adjust the CSS for <code>child-element</code> (e.g., <code>top: 10px; left: 10px;</code>) and then assert <code>is_box_contained(child_box, container_box)</code> to ensure it stays within bounds.</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Bounding box comparisons are powerful for verifying spatial relationships between elements, which is crucial for responsive layouts where elements reflow and resize.</p>
<p><strong>2. Overflow Checks: Detecting Hidden Content</strong></p>
<p>Another common layout issue is content overflow. This occurs when the content of an element is larger than the element's visible area. CSS <code>overflow</code> property (<code>hidden</code>, <code>scroll</code>, <code>auto</code>) determines how this is handled.</p>
<ul>
<li><code>overflow: hidden;</code>: Content is clipped and becomes invisible. This can be problematic if important information is truncated.</li>
<li><code>overflow: scroll;</code> or <code>auto;</code>: Scrollbars appear, which might be intended or might indicate a design flaw if unexpected.</li>
</ul>
<p>To detect overflow programmatically, we need to compare an element's <em>scroll dimensions</em> (<code>scrollWidth</code>, <code>scrollHeight</code>) with its <em>client dimensions</em> (<code>clientWidth</code>, <code>clientHeight</code>).</p>
<p><strong>Mental Model: Scroll vs. Client Dimensions</strong></p>
<ul>
<li><code>clientWidth</code> / <code>clientHeight</code>: These properties represent the inner dimensions of an element, including padding but <em>not</em> borders, margins, or scrollbars. This is the visible area available for content.</li>
<li><code>scrollWidth</code> / <code>scrollHeight</code>: These properties represent the total dimensions of the element's content, including content that is not currently visible due to overflow. If there's no overflow, these values are typically equal to or less than <code>clientWidth</code>/<code>clientHeight</code> (depending on <code>box-sizing</code> and content).</li>
</ul>
<p>If <code>scrollWidth &gt; clientWidth</code> or <code>scrollHeight &gt; clientHeight</code>, it means there is overflowed content.</p>
<p><strong>Accessing Scroll/Client Dimensions with Playwright</strong></p>
<p>Playwright doesn't have direct methods for these specific DOM properties. However, we can use <code>element_handle.evaluate()</code> to execute JavaScript in the browser context and retrieve them.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># (Conceptual - assume 'element' is a Playwright ElementHandle)</span>
<span class="token comment"># dimensions = element.evaluate("""</span>
<span class="token comment">#    el =&gt; ({</span>
<span class="token comment">#        clientWidth: el.clientWidth,</span>
<span class="token comment">#        clientHeight: el.clientHeight,</span>
<span class="token comment">#        scrollWidth: el.scrollWidth,</span>
<span class="token comment">#        scrollHeight: el.scrollHeight</span>
<span class="token comment">#    })</span>
<span class="token comment"># """)</span>
<span class="token comment"># if dimensions['scrollWidth'] &gt; dimensions['clientWidth']:</span>
<span class="token comment">#    print("Horizontal overflow detected!")</span>
<span class="token comment"># if dimensions['scrollHeight'] &gt; dimensions['clientHeight']:</span>
<span class="token comment">#    print("Vertical overflow detected!")</span>
</code></pre>
<p>Let's examine this conceptual snippet:</p>
<ol>
<li><code>element.evaluate(js_function)</code>: This method executes the provided JavaScript function in the context of the browser page. The <code>el</code> parameter within the JavaScript function refers to the DOM element corresponding to the <code>ElementHandle</code>.
<ul>
<li>The function returns an object containing the four dimension properties. This object is then available in our Python test code.</li>
<li>This is a powerful way to access any DOM property or execute arbitrary JavaScript related to an element.</li>
</ul>
</li>
</ol>
<p><strong>Example: Detecting Hidden Text Overflow</strong></p>
<p>Consider a <code>div</code> with a fixed height and <code>overflow: hidden</code>, containing more text than can fit.</p>
<p><strong>Conceptual HTML/CSS:</strong></p>
<pre class="language-html" tabindex="0"><code class="language-html"><span class="token comment">&lt;!-- THIS_CODE_SNIPPET --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">#text-box</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span> <span class="token comment">/* Fixed height */</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>
    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* Hides overflowing content */</span>
    <span class="token property">padding</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  This is a long line of text that is very likely to overflow the small fixed height of this container, especially if there are multiple lines like this one. We want to detect this overflow.
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p><strong>Playwright Test:</strong></p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token keyword">from</span> playwright<span class="token punctuation">.</span>sync_api <span class="token keyword">import</span> Page<span class="token punctuation">,</span> expect

<span class="token keyword">def</span> <span class="token function">test_detect_text_overflow</span><span class="token punctuation">(</span>page<span class="token punctuation">:</span> Page<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>set_content<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
        &lt;style&gt;
          body {{ margin: 20px; }}
          #text-box {{
            width: 200px;
            height: 50px; /* Fixed height */
            border: 1px solid black;
            overflow: hidden; /* Crucial for this test: hides overflow */
            padding: 5px; /* Padding is inside clientWidth/Height */
            font-size: 16px;
            line-height: 1.2;
          }}
        &lt;/style&gt;
        &lt;div id="text-box" data-testid="description"&gt;
          This is a long line of text that is very likely to overflow 
          the small fixed height of this container, especially if there 
          are multiple lines like this one. We want to detect this overflow 
          because important information might be hidden from the user.
        &lt;/div&gt;
    """</span><span class="token punctuation">)</span>

    text_box_locator <span class="token operator">=</span> page<span class="token punctuation">.</span>locator<span class="token punctuation">(</span><span class="token string">"[data-testid='description']"</span><span class="token punctuation">)</span>
    expect<span class="token punctuation">(</span>text_box_locator<span class="token punctuation">)</span><span class="token punctuation">.</span>to_be_visible<span class="token punctuation">(</span><span class="token punctuation">)</span>

    dimensions <span class="token operator">=</span> text_box_locator<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
        el =&gt; ({
            clientWidth: el.clientWidth,
            clientHeight: el.clientHeight,
            scrollWidth: el.scrollWidth,
            scrollHeight: el.scrollHeight
        })
    """</span><span class="token punctuation">)</span>

    <span class="token comment"># Debugging output (optional)</span>
    <span class="token comment"># print(f"Client: {dimensions['clientWidth']}w x {dimensions['clientHeight']}h")</span>
    <span class="token comment"># print(f"Scroll: {dimensions['scrollWidth']}w x {dimensions['scrollHeight']}h")</span>

    has_vertical_overflow <span class="token operator">=</span> dimensions<span class="token punctuation">[</span><span class="token string">'scrollHeight'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> dimensions<span class="token punctuation">[</span><span class="token string">'clientHeight'</span><span class="token punctuation">]</span>
    has_horizontal_overflow <span class="token operator">=</span> dimensions<span class="token punctuation">[</span><span class="token string">'scrollWidth'</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> dimensions<span class="token punctuation">[</span><span class="token string">'clientWidth'</span><span class="token punctuation">]</span>

    <span class="token comment"># For this example, we expect vertical overflow</span>
    <span class="token keyword">assert</span> has_vertical_overflow<span class="token punctuation">,</span> \
        <span class="token string-interpolation"><span class="token string">f"Expected vertical overflow. ScrollHeight (</span><span class="token interpolation"><span class="token punctuation">{</span>dimensions<span class="token punctuation">[</span><span class="token string">'scrollHeight'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">) should be &gt; ClientHeight (</span><span class="token interpolation"><span class="token punctuation">{</span>dimensions<span class="token punctuation">[</span><span class="token string">'clientHeight'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span>
    
    <span class="token comment"># Depending on content and width, horizontal overflow might also occur or not.</span>
    <span class="token comment"># For this specific text and width, it's unlikely to have horizontal overflow unless words are extremely long.</span>
    <span class="token comment"># assert not has_horizontal_overflow, "Expected no horizontal overflow for this content."</span>

    <span class="token keyword">if</span> has_vertical_overflow<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Vertical overflow detected: Content is taller than the visible area."</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> has_horizontal_overflow<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Horizontal overflow detected: Content is wider than the visible area."</span><span class="token punctuation">)</span>

</code></pre>
<p>Let's break down this test:</p>
<ol>
<li><strong><code>page.set_content(...)</code></strong>: We create HTML with a <code>div#text-box</code> styled to have a fixed <code>height</code> and <code>overflow: hidden</code>. The text content is deliberately made long enough to exceed this height.</li>
<li><strong><code>text_box_locator = page.locator("[data-testid='description']")</code></strong>: We get a locator for our target element. Using <code>data-testid</code> is a good practice for stable locators.</li>
<li><strong><code>expect(text_box_locator).to_be_visible()</code></strong>: We confirm the element is generally visible.</li>
<li><strong><code>dimensions = text_box_locator.evaluate(...)</code></strong>:
<ul>
<li>This is the core of the check. We execute JavaScript on the <code>text-box</code> element.</li>
<li>The JavaScript arrow function <code>el =&gt; ({ ... })</code> takes the DOM element (<code>el</code>) as input.</li>
<li>It returns an object containing <code>el.clientWidth</code>, <code>el.clientHeight</code>, <code>el.scrollWidth</code>, and <code>el.scrollHeight</code>. These are standard DOM properties.</li>
<li>The <code>dimensions</code> variable in Python receives this JavaScript object, converted into a Python dictionary.</li>
</ul>
</li>
<li><strong><code>has_vertical_overflow = dimensions['scrollHeight'] &gt; dimensions['clientHeight']</code></strong>: We compare the total height of the content (<code>scrollHeight</code>) with the visible height of the container (<code>clientHeight</code>). If <code>scrollHeight</code> is greater, it means some content is vertically clipped.</li>
<li><strong><code>has_horizontal_overflow = dimensions['scrollWidth'] &gt; dimensions['clientWidth']</code></strong>: Similarly, this checks for horizontal overflow.</li>
<li><strong><code>assert has_vertical_overflow, ...</code></strong>: In our example, the text is designed to cause vertical overflow, so we assert this condition is true. In a real test, you might assert that there is <em>no</em> overflow (<code>assert not has_vertical_overflow</code>) if that's the desired state.</li>
<li>The <code>print</code> statements are for demonstration; in an actual test, the assertion handles the pass/fail.</li>
</ol>
<p>This technique is invaluable for ensuring that users aren't missing critical information due to unintentional overflow, especially on smaller viewports where space is limited.</p>
<p><strong>Practical Considerations for Layout Testing</strong></p>
<ul>
<li><strong>Target Critical Elements</strong>: Programmatic layout checks can be more computationally intensive and potentially more brittle than simple presence/visibility checks. Focus them on critical UI components where layout integrity is paramount (e.g., navigation bars, main content areas, forms, call-to-action buttons).</li>
<li><strong>Sensitivity and Brittleness</strong>: Bounding box values can change by a few pixels due to font rendering differences across operating systems or minor browser updates. Design your assertions with some tolerance if exact pixel perfection isn't the goal, or focus on relative positioning and containment rather than exact coordinates. For overflow, the comparison of scroll vs. client dimensions is generally robust.</li>
<li><strong>Complementary to Visual Regression</strong>: These programmatic checks are excellent for functional layout issues (e.g., "is button A to the left of B?", "is text truncated?"). They are complementary to visual regression testing (covered in Section 15.5), which captures a broader range of visual differences by comparing screenshots.</li>
<li><strong>Responsive Design Context</strong>: These techniques are particularly powerful when testing responsive designs. You can combine them with <code>page.set_viewport_size()</code> (Section 15.1) and parameterization (Section 15.2) to verify layout integrity across various breakpoints. For example, an element might be correctly contained on desktop but overflow on mobile.</li>
<li><strong>Test Data Impact</strong>: The content within elements (text length, image sizes) can significantly affect layout. Ensure your test data for layout tests reflects realistic scenarios.</li>
</ul>
<p>By incorporating bounding box comparisons and overflow checks into your E2E testing strategy, you can catch a class of visual and functional bugs that simple assertions might miss, leading to a more polished and reliable user experience across all devices. This adds another layer of confidence that your Django application not only works but also looks and behaves correctly.</p>
<h3 id="155-screenshotting-for-visual-regression-basic-concept" tabindex="-1"><a class="anchor" href="#155-screenshotting-for-visual-regression-basic-concept" name="155-screenshotting-for-visual-regression-basic-concept" tabindex="-1"><span class="octicon octicon-link"></span></a>15.5 Screenshotting for Visual Regression (Basic Concept)</h3>
<p>Up to this point, our Playwright tests have focused on <em>functional</em> aspects: can we find elements? Can we interact with them? Does the application state change as expected? These are crucial, but they don't always catch <em>visual</em> bugs. A button might still be clickable and function correctly, but what if its color changed unexpectedly, its text is now misaligned, or it overlaps another element due to a CSS tweak? This is where Visual Regression Testing (VRT) comes into play.</p>
<p>At its core, Visual Regression Testing is the process of detecting unintended visual changes in your application's UI by comparing screenshots over time. You establish a "baseline" or "golden" set of screenshots representing the correct appearance of your UI. Then, after code changes, new screenshots are captured and compared against these baselines. Differences highlight potential visual regressions.</p>
<p>While full-fledged VRT often involves specialized tools that manage baselines, perform sophisticated image comparisons (with tolerance for minor anti-aliasing differences), and provide review workflows, we can explore the basic concept using Playwright's built-in screenshot capabilities. This will give you an intuition for how VRT works and can be a surprisingly effective way to catch obvious visual breakages, even without a dedicated VRT tool.</p>
<p><strong>The Core Idea: Baseline vs. Current Screenshot</strong></p>
<p>Imagine you have a photograph of your perfectly tidy living room â€“ this is your <strong>baseline image</strong>. Now, imagine you take another photo a week later â€“ this is your <strong>current image</strong>. By comparing these two photos, you can spot differences: perhaps a cushion is out of place, or a new magazine is on the coffee table.</p>
<p>In VRT:</p>
<ol>
<li><strong>Baseline Screenshot:</strong> A screenshot of a UI component or page that is known to be visually correct. This is your "source of truth."</li>
<li><strong>Current Screenshot:</strong> A screenshot of the same UI component or page taken after some code changes have been made.</li>
<li><strong>Comparison:</strong> The current screenshot is compared to the baseline. If there are visual differences beyond an acceptable threshold, the test fails, indicating a potential visual regression.</li>
</ol>
<p><strong>A Simple Manual Workflow for Visual Checks</strong></p>
<p>Let's outline a manual or semi-automated workflow using Playwright's <code>page.screenshot()</code> method, which we briefly encountered in Chapter 9.</p>
<ol>
<li>
<p><strong>Generate Baselines:</strong></p>
<ul>
<li>Write tests that navigate to specific pages or UI states.</li>
<li>In these tests, use <code>page.screenshot(path="path/to/baseline_image.png")</code> to capture the UI.</li>
<li>Manually inspect these initial screenshots. If they look correct, these become your baselines. It's good practice to commit these baseline images to your version control system (e.g., in a <code>tests/visual_baselines/</code> directory).</li>
</ul>
</li>
<li>
<p><strong>Run Subsequent Tests:</strong></p>
<ul>
<li>When you run your tests again after making code changes, they will capture new screenshots.</li>
<li>You would typically save these to a different directory (e.g., <code>tests/visual_actuals/</code>) or with a different naming convention to avoid overwriting your baselines immediately.</li>
</ul>
</li>
<li>
<p><strong>Compare and Review:</strong></p>
<ul>
<li>Manually compare the newly generated screenshots in <code>visual_actuals/</code> with their corresponding baselines in <code>visual_baselines/</code>.</li>
<li>Alternatively, you could use simple image comparison tools or scripts (though we won't build one here, the concept is important).</li>
</ul>
</li>
<li>
<p><strong>Update or Fix:</strong></p>
<ul>
<li>If differences are found:
<ul>
<li><strong>Intended Change:</strong> If the UI was intentionally changed and the new screenshot looks correct, update the baseline image with the new one.</li>
<li><strong>Unintended Change (Bug):</strong> If the visual difference is a bug, fix the code, and re-run the tests until the new screenshot matches the baseline.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Taking a Named Screenshot for Baseline Generation</strong></p>
<p>Let's see how you might take a screenshot intended to be a baseline. We'll need a consistent naming scheme. A good practice is to name the screenshot after the test function or a descriptive name for the UI state.</p>
<p>Consider a simple Django view and template:</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># myapp/views.py</span>
<span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render

<span class="token keyword">def</span> <span class="token function">simple_page_view</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'myapp/simple_page.html'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'message'</span><span class="token punctuation">:</span> <span class="token string">'Hello, Visual Test!'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># myapp/urls.py</span>
<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> views

urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>
    path<span class="token punctuation">(</span><span class="token string">'simple/'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>simple_page_view<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'simple_page'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># myapp/templates/myapp/simple_page.html</span>
<span class="token comment"># &lt;!DOCTYPE html&gt;</span>
<span class="token comment"># &lt;html lang="en"&gt;</span>
<span class="token comment"># &lt;head&gt;</span>
<span class="token comment">#     &lt;meta charset="UTF-8"&gt;</span>
<span class="token comment">#     &lt;title&gt;Simple Page&lt;/title&gt;</span>
<span class="token comment">#     &lt;style&gt;</span>
<span class="token comment">#         body { font-family: sans-serif; padding: 20px; }</span>
<span class="token comment">#         .message-box {</span>
<span class="token comment">#             border: 1px solid #ccc;</span>
<span class="token comment">#             padding: 15px;</span>
<span class="token comment">#             background-color: #f9f9f9;</span>
<span class="token comment">#             border-radius: 5px;</span>
<span class="token comment">#         }</span>
<span class="token comment">#         h1 { color: #333; }</span>
<span class="token comment">#     &lt;/style&gt;</span>
<span class="token comment"># &lt;/head&gt;</span>
<span class="token comment"># &lt;body&gt;</span>
<span class="token comment">#     &lt;h1&gt;Welcome to Our Simple Page&lt;/h1&gt;</span>
<span class="token comment">#     &lt;div class="message-box"&gt;</span>
<span class="token comment">#         &lt;p&gt;{{ message }}&lt;/p&gt;</span>
<span class="token comment">#     &lt;/div&gt;</span>
<span class="token comment">#     &lt;button&gt;A Sample Button&lt;/button&gt;</span>
<span class="token comment"># &lt;/body&gt;</span>
<span class="token comment"># &lt;/html&gt;</span>
</code></pre>
<p>Now, a test to capture a screenshot of this page:</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token comment"># THIS_CODE_SNIPPET</span>
<span class="token comment"># tests/test_visuals.py</span>
<span class="token keyword">import</span> pytest
<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path
<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> reverse

<span class="token comment"># Create a directory for baselines if it doesn't exist</span>
<span class="token comment"># In a real setup, you might do this in conftest.py or a fixture</span>
Path<span class="token punctuation">(</span><span class="token string">"tests/visual_baselines"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>parents<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Path<span class="token punctuation">(</span><span class="token string">"tests/visual_actuals"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>parents<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>django_db</span>
<span class="token keyword">def</span> <span class="token function">test_simple_page_visual_baseline</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> live_server<span class="token punctuation">)</span><span class="token punctuation">:</span>
    page<span class="token punctuation">.</span>goto<span class="token punctuation">(</span>live_server<span class="token punctuation">.</span>url <span class="token operator">+</span> reverse<span class="token punctuation">(</span><span class="token string">'simple_page'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment"># Define a path for the baseline screenshot</span>
    <span class="token comment"># For a real VRT system, you'd have a more robust way to manage these paths</span>
    baseline_path <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">"tests/visual_baselines/simple_page.png"</span><span class="token punctuation">)</span>
    
    <span class="token comment"># For the first run, or when intentionally updating baselines:</span>
    <span class="token comment"># You would uncomment the line below, run the test, inspect simple_page.png,</span>
    <span class="token comment"># and if it's correct, commit it.</span>
    <span class="token comment"># page.screenshot(path=baseline_path)</span>

    <span class="token comment"># For subsequent runs, you'd take a new screenshot to an "actuals" directory</span>
    actual_path <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">"tests/visual_actuals/simple_page_current.png"</span><span class="token punctuation">)</span>
    page<span class="token punctuation">.</span>screenshot<span class="token punctuation">(</span>path<span class="token operator">=</span>actual_path<span class="token punctuation">)</span>

    <span class="token comment"># --- Manual Comparison Step ---</span>
    <span class="token comment"># At this point, you would manually compare `actual_path` with `baseline_path`.</span>
    <span class="token comment"># If they differ, you'd investigate.</span>
    <span class="token comment"># For this example, we'll just assert the file was created.</span>
    <span class="token keyword">assert</span> actual_path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Actual screenshot was not created."</span>

    <span class="token comment"># A more advanced (but still basic) step could be to compare file sizes</span>
    <span class="token comment"># or use an image comparison library if the baseline exists.</span>
    <span class="token keyword">if</span> baseline_path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># This is a very naive comparison, real image diffing is complex!</span>
        <span class="token comment"># For demonstration only.</span>
        <span class="token comment"># assert actual_path.read_bytes() == baseline_path.read_bytes(), \</span>
        <span class="token comment">#    f"Visual difference detected for simple_page. Check {actual_path} against {baseline_path}"</span>
        <span class="token keyword">pass</span> <span class="token comment"># Placeholder for actual comparison logic or manual check</span>
</code></pre>
<p>Let's examine this code in detail:</p>
<ol>
<li>
<p><strong>Directory Setup</strong>:</p>
<ul>
<li><code>Path("tests/visual_baselines").mkdir(parents=True, exist_ok=True)</code> and <code>Path("tests/visual_actuals").mkdir(parents=True, exist_ok=True)</code>: We programmatically create directories to store our baseline and actual screenshots. <code>parents=True</code> ensures any necessary parent directories are also created, and <code>exist_ok=True</code> means it won't raise an error if the directory already exists. This is for convenience in our example; in a larger project, you'd ensure these directories are part of your project structure.</li>
</ul>
</li>
<li>
<p><strong>Test Function <code>test_simple_page_visual_baseline</code></strong>:</p>
<ul>
<li><code>@pytest.mark.django_db</code>: This marker is essential because our view might interact with the database (even if this simple one doesn't, it's good practice for view tests).</li>
<li><code>page, live_server</code>: We request the Playwright <code>page</code> fixture and the <code>live_server</code> fixture to access our running Django application.</li>
<li><code>page.goto(live_server.url + reverse('simple_page'))</code>: We navigate to the URL of our <code>simple_page_view</code>. Using <code>reverse()</code> makes the test resilient to URL changes.</li>
</ul>
</li>
<li>
<p><strong>Baseline Screenshot Path</strong>:</p>
<ul>
<li><code>baseline_path = Path("tests/visual_baselines/simple_page.png")</code>: We define a path where the baseline screenshot for this page will be stored. The naming convention (<code>simple_page.png</code>) makes it easy to associate with the page being tested.</li>
</ul>
</li>
<li>
<p><strong>Generating/Updating Baselines (Commented Out for Routine Runs)</strong>:</p>
<ul>
<li><code># page.screenshot(path=baseline_path)</code>: This line is crucial.
<ul>
<li><strong>First Run / Baseline Generation:</strong> You would uncomment this line, run <code>pytest</code>. Playwright will navigate to the page and save <code>simple_page.png</code> in <code>tests/visual_baselines/</code>. You then <em>manually inspect</em> this image. If it's visually perfect, you commit <code>simple_page.png</code> to your version control. This is now your "golden" image.</li>
<li><strong>Subsequent Runs:</strong> For normal test runs after the baseline is established, you'd keep this line commented out or guard it with a special command-line flag (e.g., <code>--update-baselines</code>) to prevent accidental overwrites.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Capturing Current Screenshot</strong>:</p>
<ul>
<li><code>actual_path = Path("tests/visual_actuals/simple_page_current.png")</code>: We define a path for the screenshot taken during the current test run.</li>
<li><code>page.screenshot(path=actual_path)</code>: This captures the current state of the page and saves it.</li>
</ul>
</li>
<li>
<p><strong>Manual Comparison Step (Conceptual)</strong>:</p>
<ul>
<li>The comment <code># --- Manual Comparison Step ---</code> highlights where the actual comparison would happen. In this basic setup, you'd open <code>simple_page_current.png</code> and <code>simple_page.png</code> (the baseline) and visually compare them.</li>
<li><code>assert actual_path.exists()</code>: This is a minimal assertion to confirm the screenshot was indeed created.</li>
<li>The commented-out <code>assert actual_path.read_bytes() == baseline_path.read_bytes()</code> shows a <em>very naive</em> way to programmatically compare images. <strong>This is generally unreliable for VRT</strong> because even tiny, imperceptible rendering differences (like anti-aliasing) can change pixel data and thus file bytes, leading to false positives. Real VRT tools use more sophisticated algorithms that can tolerate minor differences. We include it here to illustrate the <em>idea</em> of programmatic comparison but caution against its direct use for robust VRT.</li>
</ul>
</li>
</ol>
<p><strong>Running the Workflow:</strong></p>
<ol>
<li>
<p><strong>First Run (Generate Baseline):</strong></p>
<ul>
<li>Uncomment <code>page.screenshot(path=baseline_path)</code>.</li>
<li>Run <code>pytest tests/test_visuals.py</code>.</li>
<li>Inspect <code>tests/visual_baselines/simple_page.png</code>. If it's correct, commit it.</li>
<li>Comment out <code>page.screenshot(path=baseline_path)</code> again.</li>
</ul>
</li>
<li>
<p><strong>Subsequent Runs (Check for Regressions):</strong></p>
<ul>
<li>Make some changes to <code>myapp/templates/myapp/simple_page.html</code> (e.g., change the <code>background-color</code> of <code>.message-box</code>).</li>
<li>Run <code>pytest tests/test_visuals.py</code>.</li>
<li>A new <code>tests/visual_actuals/simple_page_current.png</code> will be generated.</li>
<li>Manually compare this new screenshot with your committed baseline. You should see the difference.</li>
<li>If the change was intended, you'd update the baseline (e.g., copy the new actual over the old baseline and commit). If it was a bug, you'd fix the HTML/CSS.</li>
</ul>
</li>
</ol>
<p>This manual process demonstrates the fundamental principle. In a real-world scenario, you'd integrate tools that automate the comparison and provide a UI for reviewing differences and updating baselines.</p>
<p><strong>Challenges and Considerations (Even at a Basic Level)</strong></p>
<p>Even with this simple approach, several challenges arise:</p>
<ol>
<li>
<p><strong>Dynamic Content:</strong> Timestamps, randomly generated content, ads, or user-specific data (like a username in the header) will cause screenshots to differ even if the underlying layout is unchanged.</p>
<ul>
<li><strong>Basic Mitigation:</strong>
<ul>
<li>Ensure your test environment uses fixed data.</li>
<li>For elements you can't control, Playwright allows you to take screenshots of specific elements (<code>element_handle.screenshot()</code>) or you might need to hide/mask dynamic regions before taking a full-page screenshot (more advanced).</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Rendering Differences:</strong> Fonts, anti-aliasing, and GPU rendering can vary slightly between operating systems, browser versions, or even different machines. This makes pixel-perfect comparison very fragile.</p>
<ul>
<li><strong>Basic Mitigation:</strong> Try to run tests in a consistent environment (e.g., a Docker container). Dedicated VRT tools often have "fuzziness" or threshold settings to ignore minor pixel differences.</li>
</ul>
</li>
<li>
<p><strong>Viewport Size:</strong> Ensure you set a consistent viewport size (<code>page.set_viewport_size()</code>) before taking screenshots, as responsive designs will look different at different widths. We covered this in Section 15.1.</p>
</li>
<li>
<p><strong>Animations and Transitions:</strong> CSS animations or transitions can mean a screenshot is taken mid-animation.</p>
<ul>
<li><strong>Basic Mitigation:</strong> Wait for animations to complete, or disable them for testing if possible (e.g., via JavaScript or specific CSS overrides for test mode).</li>
</ul>
</li>
<li>
<p><strong>Maintenance Overhead:</strong> Every time you intentionally change the UI, you need to update your baseline screenshots. This can become time-consuming for large applications.</p>
</li>
</ol>
<p><strong>When is this Basic Approach Useful?</strong></p>
<ul>
<li><strong>Quick Sanity Checks:</strong> For small projects or critical pages, having a visual reference can be a quick way to spot gross errors.</li>
<li><strong>Documenting UI States:</strong> Screenshots can serve as a form of visual documentation for specific UI states.</li>
<li><strong>Debugging UI Issues:</strong> When a functional test passes but something looks "off," taking a screenshot programmatically can help you see what the browser automation tool "saw" at that moment, which is invaluable for debugging CSS or layout problems.</li>
<li><strong>Learning the Concept:</strong> It's an excellent way to understand the fundamentals before moving to more sophisticated VRT solutions.</li>
</ul>
<p><strong>Limitations and Moving Towards Dedicated Tools</strong></p>
<p>This manual, screenshot-based approach is a conceptual introduction. For serious Visual Regression Testing, you'll quickly find its limitations:</p>
<ul>
<li><strong>Scalability:</strong> Manually comparing hundreds of images is not feasible.</li>
<li><strong>Comparison Robustness:</strong> Simple byte-comparison is too brittle. You need intelligent diffing.</li>
<li><strong>Workflow:</strong> Managing baselines, reviewing changes, and collaborating becomes difficult.</li>
</ul>
<p>Dedicated VRT tools (some of which integrate with Pytest, like <code>pytest-visual</code>, or cloud-based services like Percy or Applitools) address these issues by providing:</p>
<ul>
<li>Sophisticated image comparison algorithms (pixel diffing with thresholds, perceptual diffing).</li>
<li>A workflow for reviewing visual changes and accepting or rejecting them.</li>
<li>Baseline management.</li>
<li>Integration with CI/CD systems.</li>
</ul>
<p><strong>Summary: The Value of a Visual Checkpoint</strong></p>
<p>Introducing screenshotting, even in its most basic form, adds a new dimension to your testing strategy. It encourages you to think not just about <em>functionality</em> but also about <em>presentation</em>. While the manual process described here is rudimentary, it lays the groundwork for understanding why visual testing is important and how it complements your existing functional tests.</p>
<p>By capturing the state of your UI as an image, you create a visual checkpoint. When this checkpoint unexpectedly changes, it's a signal to investigate. As your application and test suite grow, you might consider integrating more advanced VRT tools, but the core principle of comparing a "known good" visual state with the "current" state will remain the same. For now, knowing how to take a screenshot with Playwright gives you another tool in your debugging and testing arsenal, helping you catch issues that might otherwise slip through to your users.</p>
</div></div><script>
document.addEventListener('DOMContentLoaded', function() {
  const preTags = document.querySelectorAll('pre');
  
  preTags.forEach(function(pre) {
    const existingContainer = pre.closest('.pre-container');
    if (existingContainer) {
      // If pre is already in a container (e.g. script ran multiple times or manual structure)
      // Ensure button is there or add it. For simplicity, we assume if container exists, button might too.
      // A more robust check would be to see if a .copy-btn already exists for this pre.
      // For now, let's prevent adding duplicate buttons if script re-runs on dynamic content.
      if (existingContainer.querySelector('.copy-btn')) {
          return; // Skip if button already there
      }
    }

    const container = document.createElement('div');
    container.className = 'pre-container';
    
    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.className = 'copy-btn';
    
    copyBtn.addEventListener('click', function() {
      const textToCopy = pre.innerText || pre.textContent; // .innerText is often better for user-visible text
      navigator.clipboard.writeText(textToCopy).then(
        function() {
          const originalText = copyBtn.textContent;
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');
          copyBtn.classList.remove('failed');
          
          setTimeout(function() {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove('copied');
          }, 2000);
        },
        function() {
          const originalText = copyBtn.textContent;
          copyBtn.textContent = 'Failed!';
          copyBtn.classList.add('failed');
          copyBtn.classList.remove('copied');
          
          setTimeout(function() {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove('failed');
          }, 2000);
        }
      );
    });
    
    // Structure: parent -> container -> pre & button
    if (pre.parentNode) {
        pre.parentNode.insertBefore(container, pre);
    }
    container.appendChild(pre); // Move pre into container
    container.appendChild(copyBtn); // Add button to container
  });
});
</script></body></html>